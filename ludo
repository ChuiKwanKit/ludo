#include <iostream>
#include <cstdlib>
#include <cmath>
#include <iomanip>
#include<string>
#include<ctime>
using namespace std;
//global variable

int numofHP = 1, numofTP = 2;	//number of human player and total player

class player
{
public:

	void assignbase(int a, int b) // Assign Player's base
	{
		ini = a;
		inj = b;
	}
	void assignchess(char a, char b, char c, char d) // Give name to Chess
	{
		chess[0] = a;
		chess[1] = b;
		chess[2] = c;
		chess[3] = d;
	}
	void assignlocal(int n, int x, int y) // Assign location for each chess
	{
		win = 0;
		chessi[n] = x;
		chessj[n] = y;
		if ((chessi[n] == 5) && (chessj[n] == 5))
		{
			local[n] = 1; //chess at home
		}
		else if ((chessi[n] == ini) && (chessj[n] == inj))
		{
			local[n] = 0; //chess on base
		}
		else
		{
			local[n] = 2; //chess on board
		}
		for (int a = 0; a < 4; a++) //win checker
		{
			if (local[a] == 1)
			{
				win++;
			}
		}
	}
	int showwin()
	{
		return win;
	}
	void storelocali(int n, int a)//store i location
	{
		storei[n] = a;
	}
	int showslocali(int a) //show the stored i location
	{
		return storei[a];
	}
	void storelocalj(int n, int a) //store j location
	{
		storej[n] = a;
	}
	int showslocalj(int a) //show the stored j location
	{
		return storej[a];
	}
	char showchess(int a) //show the character of chess
	{
		return chess[a];
	}
	int showchessi(int a) //show i cooradinate of chess 
	{
		return chessi[a];
	}
	int showchessj(int a) //show j cooradinate of chess 
	{
		return chessj[a];
	}

	int showlocal(int a) //show location of chess (board/home/base)
	{
		return local[a];
	}
	int showplayertype() //show comp(=0) or human(=1)
	{
		return pt;
	}
	void assignplayertype(int g) //assign playertype
	{
		pt = g;
	}

	int showini() //show base i location
	{
		return ini;
	}
	int showinj()	//show base j location
	{
		return inj;
	}

private:   //player information
	char chess[4]; //the character of chess
	int ini; //coordinate i of chess base
	int inj; //coordinate j of chess base
	int chessi[4]; //the coordinate i of chess
	int chessj[4]; //the coordinate j of chess
	int local[4];	//the location of chess (board/home/base)
	int pt;	//the player type(Human/COM)
	int storei[4];	//the stored i coordinate
	int storej[4];	//the stored j coordinate
	int win; //home counter
};

void invalid() //invalid message
{
	system("cls");
	cout << "Invaild input, please enter again!!\n";
	cin.clear();
	cin.ignore(numeric_limits<streamsize>::max(), '\n');
	system("pause");
	system("cls");
}
int errorcheck() //int validation check
{
	char a[10];
	cin.getline(a, 10);
	if (strlen(a) > 1)
	{
		return -1;
	}
	else
	{
		return int(a[0]) - 48;
	}
}
char validcheck() //char validation check
{
	char a[10];
	cin.getline(a, 10);
	if (strlen(a) > 1)
	{
		return 'z';
	}
	else
	{
		return a[0];
	}
}
int randnum()	//generate a random number
{
	int x;

	x = rand();
	srand(x + time(0));//change seed number more randomly

	return rand() % 6 + 1;
}
void bye() //exit message
{
	int const time = 5e7;
	for (int i = 10; i >= 0; i--) {
		system("cls");
		for (int j = 0; j < i; j++)
			cout << endl;
		cout << "***** *  *  **  *   * *  *    ****  **  ***\n  *   *  * *  * **  * * *     *    *  * *  *\n  *   **** **** * * * **      **** *  * *** \n  *   *  * *  * *  ** * *     *    *  * * * \n  *   *  * *  * *   * *  *    *     **  *  *\n";
		for (int k = 0; k < time; k++) {}
	}
	for (int i = 10; i >= 0; i--) {
		system("cls");
		cout << "***** *  *  **  *   * *  *    ****  **  ***\n  *   *  * *  * **  * * *     *    *  * *  *\n  *   **** **** * * * **      **** *  * *** \n  *   *  * *  * *  ** * *     *    *  * * * \n  *   *  * *  * *   * *  *    *     **  *  *\n";
		for (int j = 0; j < i; j++)
			cout << endl;
		cout << "\n\n***  *     **  *   * ***  *   *  ***\n*  * *    *  *  * *   *   **  * *   \n***  *    ****   *    *   * * * * **\n*    *    *  *   *    *   *  ** *  *\n*    **** *  *   *   ***  *   *  ** \n";
		for (int k = 0; k < time; k++) {}
	}
}
void win(int winner) //winning message
{

	int const time = 5e7;
	switch (winner) {
	case 1:
		for (int i = 10; i >= 0; i--) {
			system("cls");
			for (int j = 0; j < i; j++)
				cout << endl;
			cout << "***  *     **  *   * **** ***     **     *   * *** *   *\n*  * *    *  *  * *  *    *  *     *     * * *  *  **  *\n***  *    ****   *   **** ***      *     * * *  *  * * *\n*    *    *  *   *   *    * *      *     * * *  *  *  **\n*    **** *  *   *   **** *  *    ***     * *  *** *   *\n";
			for (int k = 0; k < time; k++) {}
		}
		for (int i = 10; i >= 0; i--) {
			system("cls");
			cout << "***  *     **  *   * **** ***     **     *   * *** *   *\n*  * *    *  *  * *  *    *  *     *     * * *  *  **  *\n***  *    ****   *   **** ***      *     * * *  *  * * *\n*    *    *  *   *   *    * *      *     * * *  *  *  **\n*    **** *  *   *   **** *  *    ***     * *  *** *   *\n";
			for (int j = 0; j < i; j++)
				cout << endl;
			cout << "\n\n **   **  *   *  ***  **  ***** *  * *     **  ***** ***  **  *   *  ***  *\n*  * *  * **  * *    *  *   *   *  * *    *  *   *    *  *  * **  * *     *\n*    *  * * * * * ** ****   *   *  * *    ****   *    *  *  * * * *  **   *\n*  * *  * *  ** *  * *  *   *   *  * *    *  *   *    *  *  * *  **    *   \n **   **  *   *  **  *  *   *    **  **** *  *   *   ***  **  *   * ***   *\n";
			for (int k = 0; k < time; k++) {}
		}break;
	case 2:
		for (int i = 10; i >= 0; i--) {
			system("cls");
			for (int j = 0; j < i; j++)
				cout << endl;
			cout << "***  *     **  *   * **** ***    ***     *   * *** *   *\n*  * *    *  *  * *  *    *  *      *    * * *  *  **  *\n***  *    ****   *   **** ***     **     * * *  *  * * *\n*    *    *  *   *   *    * *    *       * * *  *  *  **\n*    **** *  *   *   **** *  *   ****     * *  *** *   *\n";
			for (int k = 0; k < time; k++) {}
		}
		for (int i = 10; i >= 0; i--) {
			system("cls");
			cout << "***  *     **  *   * **** ***    ***     *   * *** *   *\n*  * *    *  *  * *  *    *  *      *    * * *  *  **  *\n***  *    ****   *   **** ***     **     * * *  *  * * *\n*    *    *  *   *   *    * *    *       * * *  *  *  **\n*    **** *  *   *   **** *  *   ****     * *  *** *   *\n";
			for (int j = 0; j < i; j++)
				cout << endl;
			cout << "\n\n **   **  *   *  ***  **  ***** *  * *     **  ***** ***  **  *   *  ***  *\n*  * *  * **  * *    *  *   *   *  * *    *  *   *    *  *  * **  * *     *\n*    *  * * * * * ** ****   *   *  * *    ****   *    *  *  * * * *  **   *\n*  * *  * *  ** *  * *  *   *   *  * *    *  *   *    *  *  * *  **    *   \n **   **  *   *  **  *  *   *    **  **** *  *   *   ***  **  *   * ***   *\n";
			for (int k = 0; k < time; k++) {}
		}break;
	case 3:
		for (int i = 10; i >= 0; i--) {
			system("cls");
			for (int j = 0; j < i; j++)
				cout << endl;
			cout << "***  *     **  *   * **** ***    ***     *   * *** *   *\n*  * *    *  *  * *  *    *  *      *    * * *  *  **  *\n***  *    ****   *   **** ***    ***     * * *  *  * * *\n*    *    *  *   *   *    * *       *    * * *  *  *  **\n*    **** *  *   *   **** *  *   ***      * *  *** *   *\n";
			for (int k = 0; k < time; k++) {}
		}
		for (int i = 10; i >= 0; i--) {
			system("cls");
			cout << "***  *     **  *   * **** ***    ***     *   * *** *   *\n*  * *    *  *  * *  *    *  *      *    * * *  *  **  *\n***  *    ****   *   **** ***    ***     * * *  *  * * *\n*    *    *  *   *   *    * *       *    * * *  *  *  **\n*    **** *  *   *   **** *  *   ***      * *  *** *   *\n";
			for (int j = 0; j < i; j++)
				cout << endl;
			cout << "\n\n **   **  *   *  ***  **  ***** *  * *     **  ***** ***  **  *   *  ***  *\n*  * *  * **  * *    *  *   *   *  * *    *  *   *    *  *  * **  * *     *\n*    *  * * * * * ** ****   *   *  * *    ****   *    *  *  * * * *  **   *\n*  * *  * *  ** *  * *  *   *   *  * *    *  *   *    *  *  * *  **    *   \n **   **  *   *  **  *  *   *    **  **** *  *   *   ***  **  *   * ***   *\n";
			for (int k = 0; k < time; k++) {}
		}break;
	case 4:
		for (int i = 10; i >= 0; i--) {
			system("cls");
			for (int j = 0; j < i; j++)
				cout << endl;
			cout << "***  *     **  *   * **** ***    * *     *   * *** *   *\n*  * *    *  *  * *  *    *  *   * *     * * *  *  **  *\n***  *    ****   *   **** ***    * *     * * *  *  * * *\n*    *    *  *   *   *    * *    ****    * * *  *  *  **\n*    **** *  *   *   **** *  *     *      * *  *** *   *\n";
			for (int k = 0; k < time; k++) {}
		}
		for (int i = 10; i >= 0; i--) {
			system("cls");
			cout << "***  *     **  *   * **** ***    * *     *   * *** *   *\n*  * *    *  *  * *  *    *  *   * *     * * *  *  **  *\n***  *    ****   *   **** ***    * *     * * *  *  * * *\n*    *    *  *   *   *    * *    ****    * * *  *  *  **\n*    **** *  *   *   **** *  *     *      * *  *** *   *\n";
			for (int j = 0; j < i; j++)
				cout << endl;
			cout << "\n\n **   **  *   *  ***  **  ***** *  * *     **  ***** ***  **  *   *  ***  *\n*  * *  * **  * *    *  *   *   *  * *    *  *   *    *  *  * **  * *     *\n*    *  * * * * * ** ****   *   *  * *    ****   *    *  *  * * * *  **   *\n*  * *  * *  ** *  * *  *   *   *  * *    *  *   *    *  *  * *  **    *   \n **   **  *   *  **  *  *   *    **  **** *  *   *   ***  **  *   * ***   *\n";
			for (int k = 0; k < time; k++) {}
		}
	}

}


void democase1()	// demo1 Three consecutive '6'
{

	{
		player p[4];
		int a = 0;//assign number of human player
		int countsix = 0;//roll 6 counter
		int countturn = 0;//count demo turn
		int turn = 1; //which player's turn
		int winner = 0;
		p[0].assignchess('a', 'b', 'c', 'd');
		p[1].assignchess('e', 'f', 'g', 'h');
		p[2].assignchess('i', 'j', 'k', 'l');
		p[3].assignchess('m', 'n', 'o', 'p');
		p[0].assignbase(0, -1);
		p[1].assignbase(-1, 10);
		p[2].assignbase(10, 11);
		p[3].assignbase(11, 0);
		for (int i = 0; i < 4; i++) //initial chess location (i is NO. of chess)
		{
			p[0].assignlocal(i, 0, -1);
			p[1].assignlocal(i, -1, 10);
			p[2].assignlocal(i, 10, 11);
			p[3].assignlocal(i, 11, 0);
		}
		p[0].assignlocal(0, 5, 5); //assign demo position
		p[0].assignlocal(1, 5, 5);
		p[0].assignlocal(2, 5, 5);

		p[1].assignlocal(0, 5, 5);
		p[1].assignlocal(1, 5, 5);
		p[1].assignlocal(2, 5, 5);

		char gen[12][12] = { "...........","..       ..",". .     . .",".  .   .  .",".   . .   .",".    X    .",".   . .   .",".  .   .  .",". .     . .","..       ..","..........." };
		int r;

		for (int k = 0; k < 2; k++) //assign playertype according to numofHP & numofTP
		{
			if (a > 0)
			{
				p[k].assignplayertype(1);
				a--;
			}
			else
			{
				p[k].assignplayertype(0);
			}
		}

		do //start game looping
		{
			for (int i = 0; i < 11; i++)  //display board
			{
				for (int j = 0; j < 11; j++)
					cout << gen[i][j] << " ";
				cout << endl;
			}
			for (int i = 0; i < 2; i++) // Player type (HUM/COM)
			{
				int pt;
				pt = p[i].showplayertype();
				cout << "Player " << (i + 1) << ": ";
				if (pt == 0)
				{
					cout << "COMP";
				}
				else
				{
					cout << "Human";
				}
				cout << endl << "Base: ";
				for (int j = 0; j < 4; j++)
				{
					if (p[i].showlocal(j) == 0) //chess in base
					{
						cout << p[i].showchess(j) << " ";
					}
				}
				cout << endl << "Home: ";
				for (int j = 0; j < 4; j++)
				{
					if (p[i].showlocal(j) == 1) //chess at home
					{
						cout << p[i].showchess(j) << " ";
					}
				}
				cout << endl << endl;

			}
			r = 6;
			//r = randnum(); //roll number
			cout << "Player " << turn << "'s turn ... Rolling. You get: " << r << endl;
			int vcount = 0;
			int displayF = 0;
			char chess;
			char valid[4]; //copy the chess which is movable


			switch (turn)
			{
			case 1://player 1
			{	//program for movable chess check
				for (int b = 0; b < 4; b++)
				{
					int rand = r;
					int invalid = 0;
					if ((p[0].showlocal(b) == 2)) //first valid check
					{
						int coordinatei = p[0].showchessi(b);
						int coordinatej = p[0].showchessj(b);
						do
						{
							if ((coordinatei == 0) && (coordinatej < 10)) //player1 first movement
							{
								coordinatej += rand;
								if (coordinatej > 10)
								{
									rand = coordinatej - 10;
									coordinatej = 10;
								}
								else
									rand = 0;
							}
							if ((coordinatei < 10) && (coordinatej == 10)) //player1 second movement
							{
								coordinatei += rand;
								if (coordinatei > 10)
								{
									rand = coordinatei - 10;
									coordinatei = 10;
								}
								else
									rand = 0;
							}
							if ((coordinatei == 10) && (coordinatej <= 10)) //player1 third movement
							{
								coordinatej -= rand;
								if (coordinatej < 0)
								{
									rand = -coordinatej;
									coordinatej = 0;
								}
								else
									rand = 0;
							}
							if ((coordinatei <= 10) && (coordinatej == 0) && (coordinatei > 1)) //player1 fourth movement
							{
								coordinatei -= rand;
								if (coordinatei < 1)
								{
									if (coordinatei < 0)
									{
										rand = -coordinatei + 1;
										coordinatei = 1;
									}
									else
									{
										rand = 1;
										coordinatei = 1;
									}
								}
								else
								{
									rand = 0;
								}
							}
							if ((coordinatei == 1) && (coordinatej == 0)) //player1 entry of x
							{
								if (rand == 0)
								{

								}
								else
								{
									coordinatei += rand - 1;
								}
								coordinatej += rand;
								if (coordinatei > 5)
								{
									coordinatei = 10 - coordinatei;
									coordinatej = 10 - coordinatej;
								}
								rand = 0;
							}
							if ((coordinatei >= 1) && (coordinatei < 5) && (coordinatej >= 1) && (coordinatej < 5)) //player1 X return
							{
								coordinatei += rand;
								coordinatej += rand;
								if (coordinatei > 5)
								{
									coordinatei = 10 - coordinatei;
									coordinatej = 10 - coordinatej;
									if (coordinatei == 0)
									{
										coordinatei++;
									}
								}
								rand = 0;
							}
						} while (rand > 0);


						for (int c = 0; c < 4; c++)
						{
							if ((p[0].showchessi(c) == coordinatei) && (p[0].showchessj(c) == coordinatej) && (p[0].showlocal(c) == 2) && (p[0].showchess(c) != p[0].showchess(b))) //check team chess location
								invalid++;
						}
						if (invalid == 0)
						{
							p[0].storelocali(b, coordinatei);
							p[0].storelocalj(b, coordinatej); //store the valid coordinate
							valid[vcount] = p[0].showchess(b);
							vcount++;
						}
					}
					else if ((p[0].showlocal(b) == 0) && (rand == 6)) //valid check for chess at base
					{
						int coordinatei = 0;
						int coordinatej = 0;

						for (int c = 0; c < 4; c++)
						{
							if ((p[0].showchessi(c) == coordinatei) && (p[0].showchessj(c) == coordinatej) && (p[0].showlocal(c) == 2) && (p[0].showchess(c) != p[0].showchess(b))) //check team chess location
								invalid++;
						}
						if (invalid == 0)
						{
							p[0].storelocali(b, coordinatei);
							p[0].storelocalj(b, coordinatej); //store the valid coordinate
							valid[vcount] = p[0].showchess(b);
							vcount++;
						}
					}
					else
					{
						invalid++;
					}

				}

				int Error = 1;

				if (vcount == 0) //no valid move
				{
					cout << "No possible move. Pass to next player." << endl;
					displayF++;
					system("pause");
					system("cls");
					break;
				}
				else
				{
					do
					{
						if (p[turn - 1].showplayertype() == 1)
						{
							cout << "input q to exit to game menu" << endl << endl;
						}
						cout << "Choose a chess to move: ";
						for (int i = 0; i < vcount; i++)
						{
							cout << valid[i] << " ";//show the movable chess
						}
						cout << endl;

						if (p[0].showplayertype() == 1) //if player is human
						{
							cout << "? ";
							cin >> chess;
							if (chess == 'q') //command q
							{
								char x;//input validation check
								do
								{
									cout << "Are you sure to leave the game? (Y/N):";
									cin >> x;
									if (x == 'y' || x == 'Y')
									{
										return;
									}
									else if (x == 'N' || x == 'n')
									{
										system("cls");
										for (int i = 0; i < 11; i++)  //display board
										{
											for (int j = 0; j < 11; j++)
												cout << gen[i][j] << " ";
											cout << endl;
										}
										cout << "You get: " << r << endl;
										cout << "Choose a chess to move: ";
										for (int i = 0; i < vcount; i++)
										{
											cout << valid[i] << " ";//show the movable chess
										}
										cout << endl;
										cout << "? ";
										cin >> chess;
										continue;
									}

									else
									{
										system("cls");
										invalid();
										x = 'p';
									}
								} while (x == 'p');
							}
							for (int i = 0; i < vcount; i++)
							{
								if (valid[i] == chess) //check whether the chess is movable
								{
									Error = 0; //no input error
									for (int j = 0; j < 4; j++)
									{

										if (chess == p[0].showchess(j)) //found the chess in player array  
										{
											if (p[0].showlocal(j) == 0) //case for chess at base
											{
												p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
												if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
												}
												else
												{
													for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj());//assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);//assign new board location for chess
												}
											}

											else	//case for chess on board
											{
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = '.';	//let the current position of chess be .
												p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

												if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
												}
												else
												{
													if (p[0].showlocal(j) == 1) //finish home
													{
													}
													else
													{
														for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);	//assign new board location for chess
													}



												}
											}

										}
									}
								}

							}
							if (Error == 1)
							{
								invalid();
								for (int i = 0; i < 11; i++)  //display board
								{
									for (int j = 0; j < 11; j++)
										cout << gen[i][j] << " ";
									cout << endl;
								}cout << "You get: " << r << endl;
							}
						}
						else //if player is comp
						{
							chess = valid[rand() % vcount];
							cout << "Computer chooses chess " << chess << endl << endl;

							for (int i = 0; i < vcount; i++)
							{
								Error = 0; //no input error
								if (valid[i] == chess) //check whether the chess is movable
								{
									for (int j = 0; j < 4; j++)
									{

										if (chess == p[0].showchess(j)) //found the chess in player array  
										{
											if (p[0].showlocal(j) == 0) //case for chess at base
											{
												p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
												if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
												}
												else
												{
													for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);//assign new board location for chess
												}
											}

											else	//case for chess on board
											{
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = '.';	//let the current position of chess be .
												p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

												if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
												}
												else
												{
													if (p[0].showlocal(j) == 1) //finish home
													{
													}
													else
													{
														for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);	//assign new board location for chess
													}



												}
											}

										}
									}
								}

							}

						}

					} while (Error == 1);
					break;
				}






			}
			case 2: //player 2
			{ {	//program for movable chess check
					for (int b = 0; b < 4; b++)
					{
						int rand = r;
						int invalid = 0;
						if ((p[1].showlocal(b) == 2)) //start flight (first valid check)
						{
							int coordinatei = p[1].showchessi(b);
							int coordinatej = p[1].showchessj(b);
							do
							{
								if ((coordinatei < 10) && (coordinatej == 10)) //player2 first movement
								{
									coordinatei += rand;
									if (coordinatei > 10)
									{
										rand = coordinatei - 10;
										coordinatei = 10;
									}
									else
										rand = 0;
								}
								if ((coordinatei == 10) && (coordinatej <= 10)) //player2 second movement
								{
									coordinatej -= rand;
									if (coordinatej < 0)
									{
										rand = -coordinatej;
										coordinatej = 0;
									}
									else
										rand = 0;
								}
								if ((coordinatei <= 10) && (coordinatej == 0)) //player2 third movement
								{
									coordinatei -= rand;

									if (coordinatei < 0)
									{
										rand = -coordinatei;
										coordinatei = 0;
									}
									else
									{
										rand = 0;
									}
								}
								if ((coordinatei == 0) && (coordinatej < 9)) //player2 fourth movement
								{
									coordinatej += rand;
									if (coordinatej > 9)
									{
										rand = (coordinatej - 9);
										coordinatej = 9;
									}
									else
										rand = 0;
								}



								if ((coordinatei == 0) && (coordinatej == 9)) //player2 entry of x 
								{
									coordinatei += rand;
									if (rand == 0)
									{
									}
									else
									{
										coordinatej -= (rand - 1);
									}
									if (coordinatei > 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
									}
									rand = 0;
								}
								if ((coordinatei >= 1) && (coordinatei < 5) && (coordinatej <= 9) && (coordinatej > 5)) //player2 X return
								{
									coordinatei += rand;
									coordinatej -= rand;
									if (coordinatei > 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
										if (coordinatej == 10)
										{
											coordinatej--;
										}
									}
									rand = 0;
								}
							} while (rand > 0);


							for (int c = 0; c < 4; c++)//check team chess location
							{
								if ((p[1].showchessi(c) == coordinatei) && (p[1].showlocal(c) == 2) && (p[1].showchessj(c) == coordinatej) && (p[1].showchess(c) != p[1].showchess(b)))
									invalid++;
							}
							if (invalid == 0)
							{
								p[1].storelocali(b, coordinatei);
								p[1].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[1].showchess(b);
								vcount++;
							}
						}
						else if ((p[1].showlocal(b) == 0) && (rand == 6))
						{
							int coordinatei = 0;
							int coordinatej = 10;
							for (int c = 0; c < 4; c++)//check team chess location
							{
								if ((p[1].showchessi(c) == coordinatei) && (p[1].showlocal(c) == 2) && (p[1].showchessj(c) == coordinatej) && (p[1].showchess(c) != p[1].showchess(b)))
									invalid++;
							}
							if (invalid == 0)
							{
								p[1].storelocali(b, coordinatei);
								p[1].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[1].showchess(b);
								vcount++;
							}
						}
						else
						{
							invalid++;
						}

					}

					int Error = 1;

					if (vcount == 0) //no valid move
					{
						cout << "No possible move. Pass to next player." << endl;
						displayF++;
						system("pause");
						system("cls");
						break;
					}
					else
					{
						do
						{
							if (p[turn - 1].showplayertype() == 1)
							{
								cout << "input q to exit to game menu" << endl << endl;
							}
							cout << "Choose a chess to move: ";
							for (int i = 0; i < vcount; i++)
							{
								cout << valid[i] << " ";//show the movable chess
							}
							cout << endl;

							if (p[1].showplayertype() == 1) //if player is human
							{
								cout << "? ";
								cin >> chess;
								if (chess == 'q') //command q
								{
									char x;//input validation check
									do
									{
										cout << "Are you sure to leave the game? (Y/N):";
										cin >> x;
										if (x == 'y' || x == 'Y')
										{
											return;
										}
										else if (x == 'N' || x == 'n')
										{
											system("cls");
											for (int i = 0; i < 11; i++)  //display board
											{
												for (int j = 0; j < 11; j++)
													cout << gen[i][j] << " ";
												cout << endl;
											}
											cout << "You get: " << r << endl;
											cout << "Choose a chess to move: ";
											for (int i = 0; i < vcount; i++)
											{
												cout << valid[i] << " ";//show the movable chess
											}
											cout << endl;
											cout << "? ";
											cin >> chess;
											continue;
										}

										else
										{
											system("cls");
											invalid();
											x = 'p';
										}
									} while (x == 'p');
								}
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the input chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[1].showchess(j)) //found the chess in player array  
											{
												if (p[1].showlocal(j) == 0) //case for chess at base
												{
													p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int l = 0; l < 4; l++) //check player 1 chess
														{
															if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
															{
																p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
															}
														}
														for (int m = 2; m < 4; m++) //check player 3 and 4 chess
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = '.';	//let the current position of chess be .
													p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[1].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int l = 0; l < 4; l++) //check player 1 chess
															{
																if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																	cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
																}
															}
															for (int m = 2; m < 4; m++) //check player 3 and 4 chess
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}
								}
								if (Error == 1)
								{
									invalid();
									for (int i = 0; i < 11; i++)  //display board
									{
										for (int j = 0; j < 11; j++)
											cout << gen[i][j] << " ";
										cout << endl;
									}cout << "You get: " << r << endl;
								}
							}
							else //if player is comp
							{
								chess = valid[rand() % vcount];
								cout << "Computer chooses chess " << chess << endl << endl;
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the input chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[1].showchess(j)) //found the chess in player array  
											{
												if (p[1].showlocal(j) == 0) //case for chess at base
												{
													p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int l = 0; l < 4; l++) //check player 1 chess
														{
															if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
															{
																p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
															}
														}
														for (int m = 2; m < 4; m++) //check player 3 and 4 chess
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = '.';	//let the current position of chess be .
													p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[1].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int l = 0; l < 4; l++) //check player 1 chess
															{
																if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																	cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
																}
															}
															for (int m = 2; m < 4; m++) //check player 3 and 4 chess
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}
								}

							}

						} while (Error == 1);
						break;
					}






				}
			}
			case 3://player 3
			{
				{	//program for movable chess check
					for (int b = 0; b < 4; b++)
					{
						int rand = r;
						int invalid = 0;
						if ((p[2].showlocal(b) == 2)) //start flight (first valid check)
						{
							int coordinatei = p[2].showchessi(b);
							int coordinatej = p[2].showchessj(b);
							do
							{
								if ((coordinatei == 10) && (coordinatej <= 11) && (coordinatej > 0)) //player3 first movement
								{
									coordinatej -= rand;
									if (coordinatej < 0)
									{
										rand = -coordinatej;
										coordinatej = 0;
									}
									else
										rand = 0;
								}
								if ((coordinatei <= 10) && (coordinatej == 0)) //player3 second movement
								{
									coordinatei -= rand;

									if (coordinatei < 0)
									{
										rand = -coordinatei;
										coordinatei = 0;
									}
									else
									{
										rand = 0;
									}
								}
								if ((coordinatei == 0) && (coordinatej < 10)) //player3 third movement
								{
									coordinatej += rand;
									if (coordinatej > 10)
									{
										rand = coordinatej - 10;
										coordinatej = 10;
									}
									else
										rand = 0;
								}
								if ((coordinatei < 9) && (coordinatej == 10)) //player3 fourth movement
								{
									coordinatei += rand;
									if (coordinatei > 9)
									{
										rand = coordinatei - 9;
										coordinatei = 9;
									}
									else
										rand = 0;
								}
								if ((coordinatei == 9) && (coordinatej == 10)) //player3 entry of x
								{
									if (rand == 0)
									{
									}
									else
									{
										coordinatei -= (rand - 1);
									}
									coordinatej -= rand;
									if (coordinatei < 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
									}
									rand = 0;
								}
								if ((coordinatei > 5) && (coordinatei <= 9) && (coordinatej > 5) && (coordinatej <= 9)) //player3 X return
								{
									coordinatei -= rand;
									coordinatej -= rand;
									if (coordinatei < 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
										if (coordinatei == 10)
										{
											coordinatei--;
										}
									}
									rand = 0;
								}
							} while (rand > 0);


							for (int c = 0; c < 4; c++)
							{
								if ((p[2].showchessi(c) == coordinatei) && (p[2].showchessj(c) == coordinatej) && (p[2].showlocal(c) == 2) && (p[2].showchess(c) != p[2].showchess(b))) //check team chess location
									invalid++;
							}
							if (invalid == 0)
							{
								p[2].storelocali(b, coordinatei);
								p[2].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[2].showchess(b);
								vcount++;
							}
						}
						else if ((p[2].showlocal(b) == 0) && (rand == 6))
						{
							int coordinatei = 10;
							int coordinatej = 10;
							for (int c = 0; c < 4; c++)
							{
								if ((p[2].showchessi(c) == coordinatei) && (p[2].showchessj(c) == coordinatej) && (p[2].showlocal(c) == 2) && (p[2].showchess(c) != p[2].showchess(b))) //check team chess location
									invalid++;
							}
							if (invalid == 0)
							{
								p[2].storelocali(b, coordinatei);
								p[2].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[2].showchess(b);
								vcount++;
							}
						}
						else
						{
							invalid++;
						}

					}

					int Error = 1;

					if (vcount == 0) //no valid move
					{
						cout << "No possible move. Pass to next player." << endl;
						displayF++;
						system("pause");
						system("cls");
						break;
					}
					else
					{
						do
						{
							if (p[turn - 1].showplayertype() == 1)
							{
								cout << "input q to exit to game menu" << endl << endl;
							}
							cout << "Choose a chess to move: ";
							for (int i = 0; i < vcount; i++)
							{
								cout << valid[i] << " ";//show the movable chess
							}
							cout << endl;

							if (p[2].showplayertype() == 1) //if player is human
							{
								cout << "? ";
								cin >> chess;
								if (chess == 'q') //command q
								{
									char x;//input validation check
									do
									{
										cout << "Are you sure to leave the game? (Y/N):";
										cin >> x;
										if (x == 'y' || x == 'Y')
										{
											return;
										}
										else if (x == 'N' || x == 'n')
										{
											system("cls");
											for (int i = 0; i < 11; i++)  //display board
											{
												for (int j = 0; j < 11; j++)
													cout << gen[i][j] << " ";
												cout << endl;
											}
											cout << "You get: " << r << endl;
											cout << "Choose a chess to move: ";
											for (int i = 0; i < vcount; i++)
											{
												cout << valid[i] << " ";//show the movable chess
											}
											cout << endl;
											cout << "? ";
											cin >> chess;
											continue;
										}

										else
										{
											system("cls");
											invalid();
											x = 'p';
										}
									} while (x == 'p');
								}
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[2].showchess(j)) //found the chess in player array  
											{
												if (p[2].showlocal(j) == 0) //case for chess at base
												{
													p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = '.';	//let the current position of chess be .
													p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[2].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}

								}
								if (Error == 1)
								{
									invalid();
									for (int i = 0; i < 11; i++)  //display board
									{
										for (int j = 0; j < 11; j++)
											cout << gen[i][j] << " ";
										cout << endl;
									}cout << "You get: " << r << endl;
								}
							}
							else //if player is comp
							{

								chess = valid[rand() % vcount];

								cout << "Computer chooses chess " << chess << endl << endl;
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[2].showchess(j)) //found the chess in player array  
											{
												if (p[2].showlocal(j) == 0) //case for chess at base
												{
													p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = '.';	//let the current position of chess be .
													p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[2].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}

								}
							}

						} while (Error == 1);
						break;
					}






				}
			}
			case 4: //player 4 
			{
				{
					{	//program for movable chess check
						for (int b = 0; b < 4; b++)
						{
							int rand = r;
							int invalid = 0;
							if ((p[3].showlocal(b) == 2)) //first valid check
							{
								int coordinatei = p[3].showchessi(b);
								int coordinatej = p[3].showchessj(b);
								do
								{
									if ((coordinatei <= 11) && (coordinatej == 0)) //player4 first movement
									{
										coordinatei -= rand;

										if (coordinatei < 0)
										{
											rand = -coordinatei;
											coordinatei = 0;
										}
										else
										{
											rand = 0;
										}
									}
									if ((coordinatei == 0) && (coordinatej < 10)) //player4 second movement
									{
										coordinatej += rand;
										if (coordinatej > 10)
										{
											rand = coordinatej - 10;
											coordinatej = 10;
										}
										else
											rand = 0;
									}
									if ((coordinatei < 10) && (coordinatej == 10)) //player4 third movement
									{
										coordinatei += rand;
										if (coordinatei > 10)
										{
											rand = coordinatei - 10;
											coordinatei = 10;
										}
										else
											rand = 0;
									}
									if ((coordinatei == 10) && (coordinatej <= 10) && (coordinatej > 1)) //player4 fourth movement
									{
										coordinatej -= rand;
										if (coordinatej < 1)
										{
											if (coordinatej < 0)
											{
												rand = -coordinatej + 1;
												coordinatej = 1;
											}
											else
											{
												rand = 1;
												coordinatej = 1;
											}
										}
										else
											rand = 0;
									}

									if ((coordinatei == 10) && (coordinatej == 1)) //player4 entry of x
									{
										coordinatei -= rand;
										if (rand == 0)
										{
										}
										else
										{
											coordinatej += (rand - 1);
										}
										if (coordinatei < 5)
										{
											coordinatei = 10 - coordinatei;
											coordinatej = 10 - coordinatej;
										}
										rand = 0;
									}
									if ((coordinatei > 5) && (coordinatei <= 9) && (coordinatej < 5) && (coordinatej >= 1)) //player4 X return
									{
										coordinatei -= rand;
										coordinatej += rand;
										if (coordinatei < 5)
										{
											coordinatei = 10 - coordinatei;
											coordinatej = 10 - coordinatej;
											if (coordinatei == 10)
											{
												coordinatej++;
											}
										}
										rand = 0;
									}
								} while (rand > 0);


								for (int c = 0; c < 4; c++)
								{
									if ((p[3].showchessi(c) == coordinatei) && (p[3].showchessj(c) == coordinatej) && (p[3].showlocal(c) == 2) && (p[3].showchess(c) != p[3].showchess(b))) //check team chess location
										invalid++;
								}
								if (invalid == 0)
								{
									p[3].storelocali(b, coordinatei);
									p[3].storelocalj(b, coordinatej); //store the valid coordinate
									valid[vcount] = p[3].showchess(b);
									vcount++;
								}
							}
							else if ((p[3].showlocal(b) == 0) && (rand == 6))
							{
								int coordinatei = 10;
								int coordinatej = 0;
								for (int c = 0; c < 4; c++)
								{
									if ((p[3].showchessi(c) == coordinatei) && (p[3].showchessj(c) == coordinatej) && (p[3].showlocal(c) == 2) && (p[3].showchess(c) != p[3].showchess(b))) //check team chess location
										invalid++;
								}
								if (invalid == 0)
								{
									p[3].storelocali(b, coordinatei);
									p[3].storelocalj(b, coordinatej); //store the valid coordinate
									valid[vcount] = p[3].showchess(b);
									vcount++;
								}
							}
							else
							{
								invalid++;
							}

						}

						int Error = 1;

						if (vcount == 0) //no valid move
						{
							cout << "No possible move. Pass to next player." << endl;
							displayF++;
							system("pause");
							system("cls");
							break;
						}
						else
						{
							do
							{
								if (p[turn - 1].showplayertype() == 1)
								{
									cout << "input q to exit to game menu" << endl << endl;
								}
								cout << "Choose a chess to move: ";
								for (int i = 0; i < vcount; i++)
								{
									cout << valid[i] << " ";//show the movable chess
								}
								cout << endl;

								if (p[3].showplayertype() == 1) //if player is human
								{
									cout << "? ";
									cin >> chess;
									if (chess == 'q') //command q
									{
										char x;//input validation check
										do
										{
											cout << "Are you sure to leave the game? (Y/N):";
											cin >> x;
											if (x == 'y' || x == 'Y')
											{
												return;
											}
											else if (x == 'N' || x == 'n')
											{
												system("cls");
												for (int i = 0; i < 11; i++)  //display board
												{
													for (int j = 0; j < 11; j++)
														cout << gen[i][j] << " ";
													cout << endl;
												}
												cout << "You get: " << r << endl;
												cout << "Choose a chess to move: ";
												for (int i = 0; i < vcount; i++)
												{
													cout << valid[i] << " ";//show the movable chess
												}
												cout << endl;
												cout << "? ";
												cin >> chess;
												continue;
											}

											else
											{
												system("cls");
												invalid();
												x = 'p';
											}
										} while (x == 'p');
									}
									for (int i = 0; i < vcount; i++)
									{
										if (valid[i] == chess) //check whether the chess is movable
										{
											Error = 0; //no input error
											for (int j = 0; j < 4; j++)
											{

												if (chess == p[3].showchess(j)) //found the chess in player array  
												{
													if (p[3].showlocal(j) == 0) //case for chess at base
													{
														p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
														if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
														}
														else
														{

															for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);//assign new board location for chess
														}
													}

													else	//case for chess on board
													{
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = '.';	//let the current position of chess be .
														p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

														if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
														}
														else
														{
															if (p[3].showlocal(j) == 1) //finish home
															{
															}
															else
															{

																for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);	//assign new board location for chess
															}



														}
													}

												}
											}
										}

									}
									if (Error == 1)
									{
										invalid();
										for (int i = 0; i < 11; i++)  //display board
										{
											for (int j = 0; j < 11; j++)
												cout << gen[i][j] << " ";
											cout << endl;
										}cout << "You get: " << r << endl;
									}
								}
								else //if player is comp
								{
									chess = valid[rand() % vcount];
									cout << "Computer chooses chess " << chess << endl << endl;
									for (int i = 0; i < vcount; i++)
									{
										if (valid[i] == chess) //check whether the chess is movable
										{
											Error = 0; //no input error
											for (int j = 0; j < 4; j++)
											{

												if (chess == p[3].showchess(j)) //found the chess in player array  
												{
													if (p[3].showlocal(j) == 0) //case for chess at base
													{
														p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
														if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
														}
														else
														{

															for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);//assign new board location for chess
														}
													}

													else	//case for chess on board
													{
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = '.';	//let the current position of chess be .
														p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

														if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
														}
														else
														{
															if (p[3].showlocal(j) == 1) //finish home
															{
															}
															else
															{

																for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);	//assign new board location for chess
															}



														}
													}

												}
											}
										}

									}
								}

							} while (Error == 1);
							break;
						}






					}
				}
			}
			}
			for (int w = 0; w < 4; w++) //check winner and display winner message
			{
				if (p[w].showwin() == 4)
				{
					system("pause");
					system("cls");
					cout << "The winner is player " << w + 1 << " !! Congratulation!!!" << endl;
					winner++;
					return;
				}

			}
			if ((countsix < 2) && (r == 6))
			{
				cout << endl << "Player " << turn << " get a 6 for " << countsix + 1 << " time[s]. There is a bonus round." << endl << endl;
				system("pause");
				system("cls");
				countsix++;
			}
			else
			{
				if (displayF == 0)
				{
					cout << "No more bonus move. Pass to next player." << endl;
					system("pause");
				}
				turn = turn % 2 + 1; //pass to next turn
				countsix = 0;
				system("cls");
			}
			countturn++;
			if (countturn == 4)
			{
				return;
			}
		} while (winner == 0);
	}
}

void democase2()//demo 2  Chess touches home and reverses, reaches home and wins
{
	{
		player p[4];
		int a = 0; //assign number of human player
		int countsix = 0;//roll 6 counter
		int turn = 1; //which player's turn
		int countturn = 0;//count demo turn
		int winner = 0;
		p[0].assignchess('a', 'b', 'c', 'd');
		p[1].assignchess('e', 'f', 'g', 'h');
		p[2].assignchess('i', 'j', 'k', 'l');
		p[3].assignchess('m', 'n', 'o', 'p');
		p[0].assignbase(0, -1);
		p[1].assignbase(-1, 10);
		p[2].assignbase(10, 11);
		p[3].assignbase(11, 0);
		for (int i = 0; i < 4; i++) //initial chess location (i is NO. of chess)
		{
			p[0].assignlocal(i, 0, -1);
			p[1].assignlocal(i, -1, 10);
			p[2].assignlocal(i, 10, 11);
			p[3].assignlocal(i, 11, 0);
		}
		p[0].assignlocal(0, 5, 5); //assign demo position
		p[0].assignlocal(1, 5, 5);
		p[0].assignlocal(2, 5, 5);
		p[0].assignlocal(3, 4, 4);
		p[1].assignlocal(0, 5, 5);
		p[1].assignlocal(1, 5, 5);
		p[1].assignlocal(2, 5, 5);
		p[1].assignlocal(3, 0, 4);
		char gen[12][12] = { "...........","..       ..",". .     . .",".  .   .  .",".   . .   .",".    X    .",".   . .   .",".  .   .  .",". .     . .","..       ..","..........." };
		gen[p[0].showchessi(3)][p[0].showchessj(3)] = p[0].showchess(3);
		gen[p[1].showchessi(3)][p[1].showchessj(3)] = p[1].showchess(3);
		int r;

		for (int k = 0; k < 2; k++) //assign playertype according to numofHP & numofTP
		{
			if (a > 0)
			{
				p[k].assignplayertype(1);
				a--;
			}
			else
			{
				p[k].assignplayertype(0);
			}
		}

		do //start game looping
		{
			for (int i = 0; i < 11; i++)  //display board
			{
				for (int j = 0; j < 11; j++)
					cout << gen[i][j] << " ";
				cout << endl;
			}
			for (int i = 0; i < 2; i++) // Player type (HUM/COM)
			{
				int pt;
				pt = p[i].showplayertype();
				cout << "Player " << (i + 1) << ": ";
				if (pt == 0)
				{
					cout << "COMP";
				}
				else
				{
					cout << "Human";
				}
				cout << endl << "Base: ";
				for (int j = 0; j < 4; j++)
				{
					if (p[i].showlocal(j) == 0) //chess in base
					{
						cout << p[i].showchess(j) << " ";
					}
				}
				cout << endl << "Home: ";
				for (int j = 0; j < 4; j++)
				{
					if (p[i].showlocal(j) == 1) //chess at home
					{
						cout << p[i].showchess(j) << " ";
					}
				}
				cout << endl << endl;

			}
			r = 5;
			//r = randnum(); //roll number
			cout << "Player " << turn << "'s turn ... Rolling. You get: " << r << endl;

			int vcount = 0;
			int displayF = 0;
			char chess;
			char valid[4]; //copy the chess which is movable


			switch (turn)
			{
			case 1://player 1
			{	//program for movable chess check
				for (int b = 0; b < 4; b++)
				{
					int rand = r;
					int invalid = 0;
					if ((p[0].showlocal(b) == 2)) //first valid check
					{
						int coordinatei = p[0].showchessi(b);
						int coordinatej = p[0].showchessj(b);
						do
						{
							if ((coordinatei == 0) && (coordinatej < 10)) //player1 first movement
							{
								coordinatej += rand;
								if (coordinatej > 10)
								{
									rand = coordinatej - 10;
									coordinatej = 10;
								}
								else
									rand = 0;
							}
							if ((coordinatei < 10) && (coordinatej == 10)) //player1 second movement
							{
								coordinatei += rand;
								if (coordinatei > 10)
								{
									rand = coordinatei - 10;
									coordinatei = 10;
								}
								else
									rand = 0;
							}
							if ((coordinatei == 10) && (coordinatej <= 10)) //player1 third movement
							{
								coordinatej -= rand;
								if (coordinatej < 0)
								{
									rand = -coordinatej;
									coordinatej = 0;
								}
								else
									rand = 0;
							}
							if ((coordinatei <= 10) && (coordinatej == 0) && (coordinatei > 1)) //player1 fourth movement
							{
								coordinatei -= rand;
								if (coordinatei < 1)
								{
									if (coordinatei < 0)
									{
										rand = -coordinatei + 1;
										coordinatei = 1;
									}
									else
									{
										rand = 1;
										coordinatei = 1;
									}
								}
								else
								{
									rand = 0;
								}
							}
							if ((coordinatei == 1) && (coordinatej == 0)) //player1 entry of x
							{
								if (rand == 0)
								{

								}
								else
								{
									coordinatei += rand - 1;
								}
								coordinatej += rand;
								if (coordinatei > 5)
								{
									coordinatei = 10 - coordinatei;
									coordinatej = 10 - coordinatej;
								}
								rand = 0;
							}
							if ((coordinatei >= 1) && (coordinatei < 5) && (coordinatej >= 1) && (coordinatej < 5)) //player1 X return
							{
								coordinatei += rand;
								coordinatej += rand;
								if (coordinatei > 5)
								{
									coordinatei = 10 - coordinatei;
									coordinatej = 10 - coordinatej;
									if (coordinatei == 0)
									{
										coordinatei++;
									}
								}
								rand = 0;
							}
						} while (rand > 0);


						for (int c = 0; c < 4; c++)
						{
							if ((p[0].showchessi(c) == coordinatei) && (p[0].showchessj(c) == coordinatej) && (p[0].showlocal(c) == 2) && (p[0].showchess(c) != p[0].showchess(b))) //check team chess location
								invalid++;
						}
						if (invalid == 0)
						{
							p[0].storelocali(b, coordinatei);
							p[0].storelocalj(b, coordinatej); //store the valid coordinate
							valid[vcount] = p[0].showchess(b);
							vcount++;
						}
					}
					else if ((p[0].showlocal(b) == 0) && (rand == 6)) //valid check for chess at base
					{
						int coordinatei = 0;
						int coordinatej = 0;

						for (int c = 0; c < 4; c++)
						{
							if ((p[0].showchessi(c) == coordinatei) && (p[0].showchessj(c) == coordinatej) && (p[0].showlocal(c) == 2) && (p[0].showchess(c) != p[0].showchess(b))) //check team chess location
								invalid++;
						}
						if (invalid == 0)
						{
							p[0].storelocali(b, coordinatei);
							p[0].storelocalj(b, coordinatej); //store the valid coordinate
							valid[vcount] = p[0].showchess(b);
							vcount++;
						}
					}
					else
					{
						invalid++;
					}

				}

				int Error = 1;

				if (vcount == 0) //no valid move
				{
					cout << "No possible move. Pass to next player." << endl;
					displayF++;
					system("pause");
					system("cls");
					break;
				}
				else
				{
					do
					{
						if (p[turn - 1].showplayertype() == 1)
						{
							cout << "input q to exit to game menu" << endl << endl;
						}
						cout << "Choose a chess to move: ";
						for (int i = 0; i < vcount; i++)
						{
							cout << valid[i] << " ";//show the movable chess
						}
						cout << endl;

						if (p[0].showplayertype() == 1) //if player is human
						{
							cout << "? ";
							cin >> chess;
							if (chess == 'q') //command q
							{
								char x;//input validation check
								do
								{
									cout << "Are you sure to leave the game? (Y/N):";
									cin >> x;
									if (x == 'y' || x == 'Y')
									{
										return;
									}
									else if (x == 'N' || x == 'n')
									{
										system("cls");
										for (int i = 0; i < 11; i++)  //display board
										{
											for (int j = 0; j < 11; j++)
												cout << gen[i][j] << " ";
											cout << endl;
										}
										cout << "You get: " << r << endl;
										cout << "Choose a chess to move: ";
										for (int i = 0; i < vcount; i++)
										{
											cout << valid[i] << " ";//show the movable chess
										}
										cout << endl;
										cout << "? ";
										cin >> chess;
										continue;
									}

									else
									{
										system("cls");
										invalid();
										x = 'p';
									}
								} while (x == 'p');
							}
							for (int i = 0; i < vcount; i++)
							{
								if (valid[i] == chess) //check whether the chess is movable
								{
									Error = 0; //no input error
									for (int j = 0; j < 4; j++)
									{

										if (chess == p[0].showchess(j)) //found the chess in player array  
										{
											if (p[0].showlocal(j) == 0) //case for chess at base
											{
												p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
												if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
												}
												else
												{
													for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj());//assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);//assign new board location for chess
												}
											}

											else	//case for chess on board
											{
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = '.';	//let the current position of chess be .
												p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

												if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
												}
												else
												{
													if (p[0].showlocal(j) == 1) //finish home
													{
													}
													else
													{
														for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);	//assign new board location for chess
													}



												}
											}

										}
									}
								}

							}
							if (Error == 1)
							{
								invalid();
								for (int i = 0; i < 11; i++)  //display board
								{
									for (int j = 0; j < 11; j++)
										cout << gen[i][j] << " ";
									cout << endl;
								}cout << "You get: " << r << endl;
							}
						}
						else //if player is comp
						{
							chess = valid[rand() % vcount];
							cout << "Computer chooses chess " << chess << endl << endl;

							for (int i = 0; i < vcount; i++)
							{
								Error = 0; //no input error
								if (valid[i] == chess) //check whether the chess is movable
								{
									for (int j = 0; j < 4; j++)
									{

										if (chess == p[0].showchess(j)) //found the chess in player array  
										{
											if (p[0].showlocal(j) == 0) //case for chess at base
											{
												p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
												if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
												}
												else
												{
													for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);//assign new board location for chess
												}
											}

											else	//case for chess on board
											{
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = '.';	//let the current position of chess be .
												p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

												if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
												}
												else
												{
													if (p[0].showlocal(j) == 1) //finish home
													{
													}
													else
													{
														for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);	//assign new board location for chess
													}



												}
											}

										}
									}
								}

							}

						}

					} while (Error == 1);
					break;
				}






			}
			case 2: //player 2
			{ {	//program for movable chess check
					for (int b = 0; b < 4; b++)
					{
						int rand = r;
						int invalid = 0;
						if ((p[1].showlocal(b) == 2)) //start flight (first valid check)
						{
							int coordinatei = p[1].showchessi(b);
							int coordinatej = p[1].showchessj(b);
							do
							{
								if ((coordinatei < 10) && (coordinatej == 10)) //player2 first movement
								{
									coordinatei += rand;
									if (coordinatei > 10)
									{
										rand = coordinatei - 10;
										coordinatei = 10;
									}
									else
										rand = 0;
								}
								if ((coordinatei == 10) && (coordinatej <= 10)) //player2 second movement
								{
									coordinatej -= rand;
									if (coordinatej < 0)
									{
										rand = -coordinatej;
										coordinatej = 0;
									}
									else
										rand = 0;
								}
								if ((coordinatei <= 10) && (coordinatej == 0)) //player2 third movement
								{
									coordinatei -= rand;

									if (coordinatei < 0)
									{
										rand = -coordinatei;
										coordinatei = 0;
									}
									else
									{
										rand = 0;
									}
								}
								if ((coordinatei == 0) && (coordinatej < 9)) //player2 fourth movement
								{
									coordinatej += rand;
									if (coordinatej > 9)
									{
										rand = (coordinatej - 9);
										coordinatej = 9;
									}
									else
										rand = 0;
								}



								if ((coordinatei == 0) && (coordinatej == 9)) //player2 entry of x 
								{
									coordinatei += rand;
									if (rand == 0)
									{
									}
									else
									{
										coordinatej -= (rand - 1);
									}
									if (coordinatei > 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
									}
									rand = 0;
								}
								if ((coordinatei >= 1) && (coordinatei < 5) && (coordinatej <= 9) && (coordinatej > 5)) //player2 X return
								{
									coordinatei += rand;
									coordinatej -= rand;
									if (coordinatei > 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
										if (coordinatej == 10)
										{
											coordinatej--;
										}
									}
									rand = 0;
								}
							} while (rand > 0);


							for (int c = 0; c < 4; c++)//check team chess location
							{
								if ((p[1].showchessi(c) == coordinatei) && (p[1].showlocal(c) == 2) && (p[1].showchessj(c) == coordinatej) && (p[1].showchess(c) != p[1].showchess(b)))
									invalid++;
							}
							if (invalid == 0)
							{
								p[1].storelocali(b, coordinatei);
								p[1].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[1].showchess(b);
								vcount++;
							}
						}
						else if ((p[1].showlocal(b) == 0) && (rand == 6))
						{
							int coordinatei = 0;
							int coordinatej = 10;
							for (int c = 0; c < 4; c++)//check team chess location
							{
								if ((p[1].showchessi(c) == coordinatei) && (p[1].showlocal(c) == 2) && (p[1].showchessj(c) == coordinatej) && (p[1].showchess(c) != p[1].showchess(b)))
									invalid++;
							}
							if (invalid == 0)
							{
								p[1].storelocali(b, coordinatei);
								p[1].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[1].showchess(b);
								vcount++;
							}
						}
						else
						{
							invalid++;
						}

					}

					int Error = 1;

					if (vcount == 0) //no valid move
					{
						cout << "No possible move. Pass to next player." << endl;
						displayF++;
						system("pause");
						system("cls");
						break;
					}
					else
					{
						do
						{
							if (p[turn - 1].showplayertype() == 1)
							{
								cout << "input q to exit to game menu" << endl << endl;
							}
							cout << "Choose a chess to move: ";
							for (int i = 0; i < vcount; i++)
							{
								cout << valid[i] << " ";//show the movable chess
							}
							cout << endl;

							if (p[1].showplayertype() == 1) //if player is human
							{
								cout << "? ";
								cin >> chess;
								if (chess == 'q') //command q
								{
									char x;//input validation check
									do
									{
										cout << "Are you sure to leave the game? (Y/N):";
										cin >> x;
										if (x == 'y' || x == 'Y')
										{
											return;
										}
										else if (x == 'N' || x == 'n')
										{
											system("cls");
											for (int i = 0; i < 11; i++)  //display board
											{
												for (int j = 0; j < 11; j++)
													cout << gen[i][j] << " ";
												cout << endl;
											}
											cout << "You get: " << r << endl;
											cout << "Choose a chess to move: ";
											for (int i = 0; i < vcount; i++)
											{
												cout << valid[i] << " ";//show the movable chess
											}
											cout << endl;
											cout << "? ";
											cin >> chess;
											continue;
										}

										else
										{
											system("cls");
											invalid();
											x = 'p';
										}
									} while (x == 'p');
								}
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the input chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[1].showchess(j)) //found the chess in player array  
											{
												if (p[1].showlocal(j) == 0) //case for chess at base
												{
													p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int l = 0; l < 4; l++) //check player 1 chess
														{
															if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
															{
																p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
															}
														}
														for (int m = 2; m < 4; m++) //check player 3 and 4 chess
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = '.';	//let the current position of chess be .
													p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[1].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int l = 0; l < 4; l++) //check player 1 chess
															{
																if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																	cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
																}
															}
															for (int m = 2; m < 4; m++) //check player 3 and 4 chess
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}
								}
								if (Error == 1)
								{
									invalid();
									for (int i = 0; i < 11; i++)  //display board
									{
										for (int j = 0; j < 11; j++)
											cout << gen[i][j] << " ";
										cout << endl;
									}cout << "You get: " << r << endl;
								}
							}
							else //if player is comp
							{
								chess = valid[rand() % vcount];
								cout << "Computer chooses chess " << chess << endl << endl;
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the input chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[1].showchess(j)) //found the chess in player array  
											{
												if (p[1].showlocal(j) == 0) //case for chess at base
												{
													p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int l = 0; l < 4; l++) //check player 1 chess
														{
															if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
															{
																p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
															}
														}
														for (int m = 2; m < 4; m++) //check player 3 and 4 chess
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = '.';	//let the current position of chess be .
													p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[1].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int l = 0; l < 4; l++) //check player 1 chess
															{
																if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																	cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
																}
															}
															for (int m = 2; m < 4; m++) //check player 3 and 4 chess
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}
								}

							}

						} while (Error == 1);
						break;
					}






				}
			}
			case 3://player 3
			{
				{	//program for movable chess check
					for (int b = 0; b < 4; b++)
					{
						int rand = r;
						int invalid = 0;
						if ((p[2].showlocal(b) == 2)) //start flight (first valid check)
						{
							int coordinatei = p[2].showchessi(b);
							int coordinatej = p[2].showchessj(b);
							do
							{
								if ((coordinatei == 10) && (coordinatej <= 11) && (coordinatej > 0)) //player3 first movement
								{
									coordinatej -= rand;
									if (coordinatej < 0)
									{
										rand = -coordinatej;
										coordinatej = 0;
									}
									else
										rand = 0;
								}
								if ((coordinatei <= 10) && (coordinatej == 0)) //player3 second movement
								{
									coordinatei -= rand;

									if (coordinatei < 0)
									{
										rand = -coordinatei;
										coordinatei = 0;
									}
									else
									{
										rand = 0;
									}
								}
								if ((coordinatei == 0) && (coordinatej < 10)) //player3 third movement
								{
									coordinatej += rand;
									if (coordinatej > 10)
									{
										rand = coordinatej - 10;
										coordinatej = 10;
									}
									else
										rand = 0;
								}
								if ((coordinatei < 9) && (coordinatej == 10)) //player3 fourth movement
								{
									coordinatei += rand;
									if (coordinatei > 9)
									{
										rand = coordinatei - 9;
										coordinatei = 9;
									}
									else
										rand = 0;
								}
								if ((coordinatei == 9) && (coordinatej == 10)) //player3 entry of x
								{
									if (rand == 0)
									{
									}
									else
									{
										coordinatei -= (rand - 1);
									}
									coordinatej -= rand;
									if (coordinatei < 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
									}
									rand = 0;
								}
								if ((coordinatei > 5) && (coordinatei <= 9) && (coordinatej > 5) && (coordinatej <= 9)) //player3 X return
								{
									coordinatei -= rand;
									coordinatej -= rand;
									if (coordinatei < 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
										if (coordinatei == 10)
										{
											coordinatei--;
										}
									}
									rand = 0;
								}
							} while (rand > 0);


							for (int c = 0; c < 4; c++)
							{
								if ((p[2].showchessi(c) == coordinatei) && (p[2].showchessj(c) == coordinatej) && (p[2].showlocal(c) == 2) && (p[2].showchess(c) != p[2].showchess(b))) //check team chess location
									invalid++;
							}
							if (invalid == 0)
							{
								p[2].storelocali(b, coordinatei);
								p[2].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[2].showchess(b);
								vcount++;
							}
						}
						else if ((p[2].showlocal(b) == 0) && (rand == 6))
						{
							int coordinatei = 10;
							int coordinatej = 10;
							for (int c = 0; c < 4; c++)
							{
								if ((p[2].showchessi(c) == coordinatei) && (p[2].showchessj(c) == coordinatej) && (p[2].showlocal(c) == 2) && (p[2].showchess(c) != p[2].showchess(b))) //check team chess location
									invalid++;
							}
							if (invalid == 0)
							{
								p[2].storelocali(b, coordinatei);
								p[2].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[2].showchess(b);
								vcount++;
							}
						}
						else
						{
							invalid++;
						}

					}

					int Error = 1;

					if (vcount == 0) //no valid move
					{
						cout << "No possible move. Pass to next player." << endl;
						displayF++;
						system("pause");
						system("cls");
						break;
					}
					else
					{
						do
						{
							if (p[turn - 1].showplayertype() == 1)
							{
								cout << "input q to exit to game menu" << endl << endl;
							}
							cout << "Choose a chess to move: ";
							for (int i = 0; i < vcount; i++)
							{
								cout << valid[i] << " ";//show the movable chess
							}
							cout << endl;

							if (p[2].showplayertype() == 1) //if player is human
							{
								cout << "? ";
								cin >> chess;
								if (chess == 'q') //command q
								{
									char x;//input validation check
									do
									{
										cout << "Are you sure to leave the game? (Y/N):";
										cin >> x;
										if (x == 'y' || x == 'Y')
										{
											return;
										}
										else if (x == 'N' || x == 'n')
										{
											system("cls");
											for (int i = 0; i < 11; i++)  //display board
											{
												for (int j = 0; j < 11; j++)
													cout << gen[i][j] << " ";
												cout << endl;
											}
											cout << "You get: " << r << endl;
											cout << "Choose a chess to move: ";
											for (int i = 0; i < vcount; i++)
											{
												cout << valid[i] << " ";//show the movable chess
											}
											cout << endl;
											cout << "? ";
											cin >> chess;
											continue;
										}

										else
										{
											system("cls");
											invalid();
											x = 'p';
										}
									} while (x == 'p');
								}
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[2].showchess(j)) //found the chess in player array  
											{
												if (p[2].showlocal(j) == 0) //case for chess at base
												{
													p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = '.';	//let the current position of chess be .
													p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[2].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}

								}
								if (Error == 1)
								{
									invalid();
									for (int i = 0; i < 11; i++)  //display board
									{
										for (int j = 0; j < 11; j++)
											cout << gen[i][j] << " ";
										cout << endl;
									}cout << "You get: " << r << endl;
								}
							}
							else //if player is comp
							{
								chess = valid[rand() % vcount];
								cout << "Computer chooses chess " << chess << endl << endl;
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[2].showchess(j)) //found the chess in player array  
											{
												if (p[2].showlocal(j) == 0) //case for chess at base
												{
													p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = '.';	//let the current position of chess be .
													p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[2].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}

								}
							}

						} while (Error == 1);
						break;
					}






				}
			}
			case 4: //player 4 
			{
				{
					{	//program for movable chess check
						for (int b = 0; b < 4; b++)
						{
							int rand = r;
							int invalid = 0;
							if ((p[3].showlocal(b) == 2)) //first valid check
							{
								int coordinatei = p[3].showchessi(b);
								int coordinatej = p[3].showchessj(b);
								do
								{
									if ((coordinatei <= 11) && (coordinatej == 0)) //player4 first movement
									{
										coordinatei -= rand;

										if (coordinatei < 0)
										{
											rand = -coordinatei;
											coordinatei = 0;
										}
										else
										{
											rand = 0;
										}
									}
									if ((coordinatei == 0) && (coordinatej < 10)) //player4 second movement
									{
										coordinatej += rand;
										if (coordinatej > 10)
										{
											rand = coordinatej - 10;
											coordinatej = 10;
										}
										else
											rand = 0;
									}
									if ((coordinatei < 10) && (coordinatej == 10)) //player4 third movement
									{
										coordinatei += rand;
										if (coordinatei > 10)
										{
											rand = coordinatei - 10;
											coordinatei = 10;
										}
										else
											rand = 0;
									}
									if ((coordinatei == 10) && (coordinatej <= 10) && (coordinatej > 1)) //player4 fourth movement
									{
										coordinatej -= rand;
										if (coordinatej < 1)
										{
											if (coordinatej < 0)
											{
												rand = -coordinatej + 1;
												coordinatej = 1;
											}
											else
											{
												rand = 1;
												coordinatej = 1;
											}
										}
										else
											rand = 0;
									}

									if ((coordinatei == 10) && (coordinatej == 1)) //player4 entry of x
									{
										coordinatei -= rand;
										if (rand == 0)
										{
										}
										else
										{
											coordinatej += (rand - 1);
										}
										if (coordinatei < 5)
										{
											coordinatei = 10 - coordinatei;
											coordinatej = 10 - coordinatej;
										}
										rand = 0;
									}
									if ((coordinatei > 5) && (coordinatei <= 9) && (coordinatej < 5) && (coordinatej >= 1)) //player4 X return
									{
										coordinatei -= rand;
										coordinatej += rand;
										if (coordinatei < 5)
										{
											coordinatei = 10 - coordinatei;
											coordinatej = 10 - coordinatej;
											if (coordinatei == 10)
											{
												coordinatej++;
											}
										}
										rand = 0;
									}
								} while (rand > 0);


								for (int c = 0; c < 4; c++)
								{
									if ((p[3].showchessi(c) == coordinatei) && (p[3].showchessj(c) == coordinatej) && (p[3].showlocal(c) == 2) && (p[3].showchess(c) != p[3].showchess(b))) //check team chess location
										invalid++;
								}
								if (invalid == 0)
								{
									p[3].storelocali(b, coordinatei);
									p[3].storelocalj(b, coordinatej); //store the valid coordinate
									valid[vcount] = p[3].showchess(b);
									vcount++;
								}
							}
							else if ((p[3].showlocal(b) == 0) && (rand == 6))
							{
								int coordinatei = 10;
								int coordinatej = 0;
								for (int c = 0; c < 4; c++)
								{
									if ((p[3].showchessi(c) == coordinatei) && (p[3].showchessj(c) == coordinatej) && (p[3].showlocal(c) == 2) && (p[3].showchess(c) != p[3].showchess(b))) //check team chess location
										invalid++;
								}
								if (invalid == 0)
								{
									p[3].storelocali(b, coordinatei);
									p[3].storelocalj(b, coordinatej); //store the valid coordinate
									valid[vcount] = p[3].showchess(b);
									vcount++;
								}
							}
							else
							{
								invalid++;
							}

						}

						int Error = 1;

						if (vcount == 0) //no valid move
						{
							cout << "No possible move. Pass to next player." << endl;
							displayF++;
							system("pause");
							system("cls");
							break;
						}
						else
						{
							do
							{
								if (p[turn - 1].showplayertype() == 1)
								{
									cout << "input q to exit to game menu" << endl << endl;
								}
								cout << "Choose a chess to move: ";
								for (int i = 0; i < vcount; i++)
								{
									cout << valid[i] << " ";//show the movable chess
								}
								cout << endl;

								if (p[3].showplayertype() == 1) //if player is human
								{
									cout << "? ";
									cin >> chess;
									if (chess == 'q') //command q
									{
										char x;//input validation check
										do
										{
											cout << "Are you sure to leave the game? (Y/N):";
											cin >> x;
											if (x == 'y' || x == 'Y')
											{
												return;
											}
											else if (x == 'N' || x == 'n')
											{
												system("cls");
												for (int i = 0; i < 11; i++)  //display board
												{
													for (int j = 0; j < 11; j++)
														cout << gen[i][j] << " ";
													cout << endl;
												}
												cout << "You get: " << r << endl;
												cout << "Choose a chess to move: ";
												for (int i = 0; i < vcount; i++)
												{
													cout << valid[i] << " ";//show the movable chess
												}
												cout << endl;
												cout << "? ";
												cin >> chess;
												continue;
											}

											else
											{
												system("cls");
												invalid();
												x = 'p';
											}
										} while (x == 'p');
									}
									for (int i = 0; i < vcount; i++)
									{
										if (valid[i] == chess) //check whether the chess is movable
										{
											Error = 0; //no input error
											for (int j = 0; j < 4; j++)
											{

												if (chess == p[3].showchess(j)) //found the chess in player array  
												{
													if (p[3].showlocal(j) == 0) //case for chess at base
													{
														p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
														if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
														}
														else
														{

															for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);//assign new board location for chess
														}
													}

													else	//case for chess on board
													{
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = '.';	//let the current position of chess be .
														p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

														if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
														}
														else
														{
															if (p[3].showlocal(j) == 1) //finish home
															{
															}
															else
															{

																for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);	//assign new board location for chess
															}



														}
													}

												}
											}
										}

									}
									if (Error == 1)
									{
										invalid();
										for (int i = 0; i < 11; i++)  //display board
										{
											for (int j = 0; j < 11; j++)
												cout << gen[i][j] << " ";
											cout << endl;
										}cout << "You get: " << r << endl;
									}
								}
								else //if player is comp
								{
									chess = valid[rand() % vcount];
									cout << "Computer chooses chess " << chess << endl << endl;
									for (int i = 0; i < vcount; i++)
									{
										if (valid[i] == chess) //check whether the chess is movable
										{
											Error = 0; //no input error
											for (int j = 0; j < 4; j++)
											{

												if (chess == p[3].showchess(j)) //found the chess in player array  
												{
													if (p[3].showlocal(j) == 0) //case for chess at base
													{
														p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
														if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
														}
														else
														{

															for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);//assign new board location for chess
														}
													}

													else	//case for chess on board
													{
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = '.';	//let the current position of chess be .
														p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

														if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
														}
														else
														{
															if (p[3].showlocal(j) == 1) //finish home
															{
															}
															else
															{

																for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);	//assign new board location for chess
															}



														}
													}

												}
											}
										}

									}
								}

							} while (Error == 1);
							break;
						}






					}
				}
			}
			}

			for (int w = 0; w < 4; w++) //check winner and display winner message
			{
				if (p[w].showwin() == 4)
				{
					system("pause");
					system("cls");
					win(w + 1);
					winner++;
					return;
				}

			}
			if ((countsix < 2) && (r == 6))
			{
				cout << endl << "Player " << turn << " get a 6 for " << countsix + 1 << " time[s]. There is a bonus round." << endl << endl;
				system("pause");
				system("cls");
				countsix++;
			}
			else
			{
				if (displayF == 0)
				{
					cout << "No more bonus move. Pass to next player." << endl;
					system("pause");
				}
				turn = turn % 2 + 1; //pass to next turn
				countsix = 0;
				system("cls");
			}
			countturn++;
			if (countturn == 4)
			{
				return;
			}
		} while (winner == 0);
	}
}

void democase3()// democase3 Chess does not self - overlap, and sends back opponent chess
{

	{

		{
			player p[4];
			int a = 0;
			int countsix = 0;//roll 6 counter
			int countturn = 0; //count demo turn
			int turn = 1; //which player's turn
			int winner = 0;
			p[0].assignchess('a', 'b', 'c', 'd');
			p[1].assignchess('e', 'f', 'g', 'h');
			p[2].assignchess('i', 'j', 'k', 'l');
			p[3].assignchess('m', 'n', 'o', 'p');
			p[0].assignbase(0, -1);
			p[1].assignbase(-1, 10);
			p[2].assignbase(10, 11);
			p[3].assignbase(11, 0);
			for (int i = 0; i < 4; i++) //initial chess location (i is NO. of chess)
			{
				p[0].assignlocal(i, 0, -1);
				p[1].assignlocal(i, -1, 10);
				p[2].assignlocal(i, 10, 11);
				p[3].assignlocal(i, 11, 0);
			}
			p[0].assignlocal(0, 5, 5); //assign demo position
			p[0].assignlocal(1, 5, 5);
			p[0].assignlocal(2, 0, 9);
			p[0].assignlocal(3, 0, 3);
			p[1].assignlocal(0, 5, 5);
			p[1].assignlocal(1, 5, 5);
			p[1].assignlocal(2, 5, 5);
			p[1].assignlocal(3, 5, 10);
			char gen[12][12] = { "...........","..       ..",". .     . .",".  .   .  .",".   . .   .",".    X    .",".   . .   .",".  .   .  .",". .     . .","..       ..","..........." };
			int r;
			gen[p[0].showchessi(2)][p[0].showchessj(2)] = p[0].showchess(2);
			gen[p[0].showchessi(3)][p[0].showchessj(3)] = p[0].showchess(3);
			gen[p[1].showchessi(3)][p[1].showchessj(3)] = p[1].showchess(3);
			for (int k = 0; k < 2; k++) //assign playertype according to numofHP & numofTP
			{
				if (a > 0)
				{
					p[k].assignplayertype(1);
					a--;
				}
				else
				{
					p[k].assignplayertype(0);
				}
			}

			do //start game looping
			{
				for (int i = 0; i < 11; i++)  //display board
				{
					for (int j = 0; j < 11; j++)
						cout << gen[i][j] << " ";
					cout << endl;
				}
				for (int i = 0; i < 2; i++) // Player type (HUM/COM)
				{
					int pt;
					pt = p[i].showplayertype();
					cout << "Player " << (i + 1) << ": ";
					if (pt == 0)
					{
						cout << "COMP";
					}
					else
					{
						cout << "Human";
					}
					cout << endl << "Base: ";
					for (int j = 0; j < 4; j++)
					{
						if (p[i].showlocal(j) == 0) //chess in base
						{
							cout << p[i].showchess(j) << " ";
						}
					}
					cout << endl << "Home: ";
					for (int j = 0; j < 4; j++)
					{
						if (p[i].showlocal(j) == 1) //chess at home
						{
							cout << p[i].showchess(j) << " ";
						}
					}
					cout << endl << endl;

				}
				r = 6;
				//r = randnum(); //roll number
				cout << "Player " << turn << "'s turn ... Rolling. You get: " << r << endl;

				int vcount = 0;
				int displayF = 0;
				char chess;
				char valid[4]; //copy the chess which is movable


				switch (turn)
				{
				case 1://player 1
				{	//program for movable chess check
					for (int b = 0; b < 4; b++)
					{
						int rand = r;
						int invalid = 0;
						if ((p[0].showlocal(b) == 2)) //first valid check
						{
							int coordinatei = p[0].showchessi(b);
							int coordinatej = p[0].showchessj(b);
							do
							{
								if ((coordinatei == 0) && (coordinatej < 10)) //player1 first movement
								{
									coordinatej += rand;
									if (coordinatej > 10)
									{
										rand = coordinatej - 10;
										coordinatej = 10;
									}
									else
										rand = 0;
								}
								if ((coordinatei < 10) && (coordinatej == 10)) //player1 second movement
								{
									coordinatei += rand;
									if (coordinatei > 10)
									{
										rand = coordinatei - 10;
										coordinatei = 10;
									}
									else
										rand = 0;
								}
								if ((coordinatei == 10) && (coordinatej <= 10)) //player1 third movement
								{
									coordinatej -= rand;
									if (coordinatej < 0)
									{
										rand = -coordinatej;
										coordinatej = 0;
									}
									else
										rand = 0;
								}
								if ((coordinatei <= 10) && (coordinatej == 0) && (coordinatei > 1)) //player1 fourth movement
								{
									coordinatei -= rand;
									if (coordinatei < 1)
									{
										if (coordinatei < 0)
										{
											rand = -coordinatei + 1;
											coordinatei = 1;
										}
										else
										{
											rand = 1;
											coordinatei = 1;
										}
									}
									else
									{
										rand = 0;
									}
								}
								if ((coordinatei == 1) && (coordinatej == 0)) //player1 entry of x
								{
									if (rand == 0)
									{

									}
									else
									{
										coordinatei += rand - 1;
									}
									coordinatej += rand;
									if (coordinatei > 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
									}
									rand = 0;
								}
								if ((coordinatei >= 1) && (coordinatei < 5) && (coordinatej >= 1) && (coordinatej < 5)) //player1 X return
								{
									coordinatei += rand;
									coordinatej += rand;
									if (coordinatei > 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
										if (coordinatei == 0)
										{
											coordinatei++;
										}
									}
									rand = 0;
								}
							} while (rand > 0);


							for (int c = 0; c < 4; c++)
							{
								if ((p[0].showchessi(c) == coordinatei) && (p[0].showchessj(c) == coordinatej) && (p[0].showlocal(c) == 2) && (p[0].showchess(c) != p[0].showchess(b))) //check team chess location
									invalid++;
							}
							if (invalid == 0)
							{
								p[0].storelocali(b, coordinatei);
								p[0].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[0].showchess(b);
								vcount++;
							}
						}
						else if ((p[0].showlocal(b) == 0) && (rand == 6)) //valid check for chess at base
						{
							int coordinatei = 0;
							int coordinatej = 0;

							for (int c = 0; c < 4; c++)
							{
								if ((p[0].showchessi(c) == coordinatei) && (p[0].showchessj(c) == coordinatej) && (p[0].showlocal(c) == 2) && (p[0].showchess(c) != p[0].showchess(b))) //check team chess location
									invalid++;
							}
							if (invalid == 0)
							{
								p[0].storelocali(b, coordinatei);
								p[0].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[0].showchess(b);
								vcount++;
							}
						}
						else
						{
							invalid++;
						}

					}

					int Error = 1;

					if (vcount == 0) //no valid move
					{
						cout << "No possible move. Pass to next player." << endl;
						displayF++;
						system("pause");
						system("cls");
						break;
					}
					else
					{
						do
						{
							if (p[turn - 1].showplayertype() == 1)
							{
								cout << "input q to exit to game menu" << endl << endl;
							}
							cout << "Choose a chess to move: ";
							for (int i = 0; i < vcount; i++)
							{
								cout << valid[i] << " ";//show the movable chess
							}
							cout << endl;

							if (p[0].showplayertype() == 1) //if player is human
							{
								cout << "? ";
								cin >> chess;
								if (chess == 'q') //command q
								{
									char x;//input validation check
									do
									{
										cout << "Are you sure to leave the game? (Y/N):";
										cin >> x;
										if (x == 'y' || x == 'Y')
										{
											return;
										}
										else if (x == 'N' || x == 'n')
										{
											system("cls");
											for (int i = 0; i < 11; i++)  //display board
											{
												for (int j = 0; j < 11; j++)
													cout << gen[i][j] << " ";
												cout << endl;
											}
											cout << "You get: " << r << endl;
											cout << "Choose a chess to move: ";
											for (int i = 0; i < vcount; i++)
											{
												cout << valid[i] << " ";//show the movable chess
											}
											cout << endl;
											cout << "? ";
											cin >> chess;
											continue;
										}

										else
										{
											system("cls");
											invalid();
											x = 'p';
										}
									} while (x == 'p');
								}
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[0].showchess(j)) //found the chess in player array  
											{
												if (p[0].showlocal(j) == 0) //case for chess at base
												{
													p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj());//assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = '.';	//let the current position of chess be .
													p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[0].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}

								}
								if (Error == 1)
								{
									invalid();
									for (int i = 0; i < 11; i++)  //display board
									{
										for (int j = 0; j < 11; j++)
											cout << gen[i][j] << " ";
										cout << endl;
									}cout << "You get: " << r << endl;
								}
							}
							else //if player is comp
							{
								int haved = 0;
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == 'd')
										haved++;
								}
								if (haved > 0)
								{
									chess = 'd';
								}
								else
								{
									chess = valid[rand() % vcount];
								}
								cout << "Computer chooses chess " << chess << endl << endl;

								for (int i = 0; i < vcount; i++)
								{
									Error = 0; //no input error
									if (valid[i] == chess) //check whether the chess is movable
									{
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[0].showchess(j)) //found the chess in player array  
											{
												if (p[0].showlocal(j) == 0) //case for chess at base
												{
													p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
													}
													else
													{
														for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = '.';	//let the current position of chess be .
													p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[0].showlocal(j) == 1) //finish home
														{
														}
														else
														{
															for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}

								}

							}

						} while (Error == 1);
						break;
					}






				}
				case 2: //player 2
				{ {	//program for movable chess check
						for (int b = 0; b < 4; b++)
						{
							int rand = r;
							int invalid = 0;
							if ((p[1].showlocal(b) == 2)) //start flight (first valid check)
							{
								int coordinatei = p[1].showchessi(b);
								int coordinatej = p[1].showchessj(b);
								do
								{
									if ((coordinatei < 10) && (coordinatej == 10)) //player2 first movement
									{
										coordinatei += rand;
										if (coordinatei > 10)
										{
											rand = coordinatei - 10;
											coordinatei = 10;
										}
										else
											rand = 0;
									}
									if ((coordinatei == 10) && (coordinatej <= 10)) //player2 second movement
									{
										coordinatej -= rand;
										if (coordinatej < 0)
										{
											rand = -coordinatej;
											coordinatej = 0;
										}
										else
											rand = 0;
									}
									if ((coordinatei <= 10) && (coordinatej == 0)) //player2 third movement
									{
										coordinatei -= rand;

										if (coordinatei < 0)
										{
											rand = -coordinatei;
											coordinatei = 0;
										}
										else
										{
											rand = 0;
										}
									}
									if ((coordinatei == 0) && (coordinatej < 9)) //player2 fourth movement
									{
										coordinatej += rand;
										if (coordinatej > 9)
										{
											rand = (coordinatej - 9);
											coordinatej = 9;
										}
										else
											rand = 0;
									}



									if ((coordinatei == 0) && (coordinatej == 9)) //player2 entry of x 
									{
										coordinatei += rand;
										if (rand == 0)
										{
										}
										else
										{
											coordinatej -= (rand - 1);
										}
										if (coordinatei > 5)
										{
											coordinatei = 10 - coordinatei;
											coordinatej = 10 - coordinatej;
										}
										rand = 0;
									}
									if ((coordinatei >= 1) && (coordinatei < 5) && (coordinatej <= 9) && (coordinatej > 5)) //player2 X return
									{
										coordinatei += rand;
										coordinatej -= rand;
										if (coordinatei > 5)
										{
											coordinatei = 10 - coordinatei;
											coordinatej = 10 - coordinatej;
											if (coordinatej == 10)
											{
												coordinatej--;
											}
										}
										rand = 0;
									}
								} while (rand > 0);


								for (int c = 0; c < 4; c++)//check team chess location
								{
									if ((p[1].showchessi(c) == coordinatei) && (p[1].showlocal(c) == 2) && (p[1].showchessj(c) == coordinatej) && (p[1].showchess(c) != p[1].showchess(b)))
										invalid++;
								}
								if (invalid == 0)
								{
									p[1].storelocali(b, coordinatei);
									p[1].storelocalj(b, coordinatej); //store the valid coordinate
									valid[vcount] = p[1].showchess(b);
									vcount++;
								}
							}
							else if ((p[1].showlocal(b) == 0) && (rand == 6))
							{
								int coordinatei = 0;
								int coordinatej = 10;
								for (int c = 0; c < 4; c++)//check team chess location
								{
									if ((p[1].showchessi(c) == coordinatei) && (p[1].showlocal(c) == 2) && (p[1].showchessj(c) == coordinatej) && (p[1].showchess(c) != p[1].showchess(b)))
										invalid++;
								}
								if (invalid == 0)
								{
									p[1].storelocali(b, coordinatei);
									p[1].storelocalj(b, coordinatej); //store the valid coordinate
									valid[vcount] = p[1].showchess(b);
									vcount++;
								}
							}
							else
							{
								invalid++;
							}

						}

						int Error = 1;

						if (vcount == 0) //no valid move
						{
							cout << "No possible move. Pass to next player." << endl;
							displayF++;
							system("pause");
							system("cls");
							break;
						}
						else
						{
							do
							{
								if (p[turn - 1].showplayertype() == 1)
								{
									cout << "input q to exit to game menu" << endl << endl;
								}
								cout << "Choose a chess to move: ";
								for (int i = 0; i < vcount; i++)
								{
									cout << valid[i] << " ";//show the movable chess
								}
								cout << endl;

								if (p[1].showplayertype() == 1) //if player is human
								{
									cout << "? ";
									cin >> chess;
									if (chess == 'q') //command q
									{
										char x;//input validation check
										do
										{
											cout << "Are you sure to leave the game? (Y/N):";
											cin >> x;
											if (x == 'y' || x == 'Y')
											{
												return;
											}
											else if (x == 'N' || x == 'n')
											{
												system("cls");
												for (int i = 0; i < 11; i++)  //display board
												{
													for (int j = 0; j < 11; j++)
														cout << gen[i][j] << " ";
													cout << endl;
												}
												cout << "You get: " << r << endl;
												cout << "Choose a chess to move: ";
												for (int i = 0; i < vcount; i++)
												{
													cout << valid[i] << " ";//show the movable chess
												}
												cout << endl;
												cout << "? ";
												cin >> chess;
												continue;
											}

											else
											{
												system("cls");
												invalid();
												x = 'p';
											}
										} while (x == 'p');
									}
									for (int i = 0; i < vcount; i++)
									{
										if (valid[i] == chess) //check whether the input chess is movable
										{
											Error = 0; //no input error
											for (int j = 0; j < 4; j++)
											{

												if (chess == p[1].showchess(j)) //found the chess in player array  
												{
													if (p[1].showlocal(j) == 0) //case for chess at base
													{
														p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
														if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
														}
														else
														{
															for (int l = 0; l < 4; l++) //check player 1 chess
															{
																if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																	cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
																}
															}
															for (int m = 2; m < 4; m++) //check player 3 and 4 chess
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
														}
													}

													else	//case for chess on board
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = '.';	//let the current position of chess be .
														p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

														if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
														}
														else
														{
															if (p[1].showlocal(j) == 1) //finish home
															{
															}
															else
															{
																for (int l = 0; l < 4; l++) //check player 1 chess
																{
																	if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																	{
																		p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																		cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
																	}
																}
																for (int m = 2; m < 4; m++) //check player 3 and 4 chess
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
															}



														}
													}

												}
											}
										}
									}
									if (Error == 1)
									{
										invalid();
										for (int i = 0; i < 11; i++)  //display board
										{
											for (int j = 0; j < 11; j++)
												cout << gen[i][j] << " ";
											cout << endl;
										}cout << "You get: " << r << endl;
									}
								}
								else //if player is comp
								{
									chess = valid[rand() % vcount];
									cout << "Computer chooses chess " << chess << endl << endl;
									for (int i = 0; i < vcount; i++)
									{
										if (valid[i] == chess) //check whether the input chess is movable
										{
											Error = 0; //no input error
											for (int j = 0; j < 4; j++)
											{

												if (chess == p[1].showchess(j)) //found the chess in player array  
												{
													if (p[1].showlocal(j) == 0) //case for chess at base
													{
														p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
														if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
														}
														else
														{
															for (int l = 0; l < 4; l++) //check player 1 chess
															{
																if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																	cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
																}
															}
															for (int m = 2; m < 4; m++) //check player 3 and 4 chess
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
														}
													}

													else	//case for chess on board
													{
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = '.';	//let the current position of chess be .
														p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

														if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
														}
														else
														{
															if (p[1].showlocal(j) == 1) //finish home
															{
															}
															else
															{
																for (int l = 0; l < 4; l++) //check player 1 chess
																{
																	if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																	{
																		p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																		cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
																	}
																}
																for (int m = 2; m < 4; m++) //check player 3 and 4 chess
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
															}



														}
													}

												}
											}
										}
									}

								}

							} while (Error == 1);
							break;
						}






					}
				}
				case 3://player 3
				{
					{	//program for movable chess check
						for (int b = 0; b < 4; b++)
						{
							int rand = r;
							int invalid = 0;
							if ((p[2].showlocal(b) == 2)) //start flight (first valid check)
							{
								int coordinatei = p[2].showchessi(b);
								int coordinatej = p[2].showchessj(b);
								do
								{
									if ((coordinatei == 10) && (coordinatej <= 11) && (coordinatej > 0)) //player3 first movement
									{
										coordinatej -= rand;
										if (coordinatej < 0)
										{
											rand = -coordinatej;
											coordinatej = 0;
										}
										else
											rand = 0;
									}
									if ((coordinatei <= 10) && (coordinatej == 0)) //player3 second movement
									{
										coordinatei -= rand;

										if (coordinatei < 0)
										{
											rand = -coordinatei;
											coordinatei = 0;
										}
										else
										{
											rand = 0;
										}
									}
									if ((coordinatei == 0) && (coordinatej < 10)) //player3 third movement
									{
										coordinatej += rand;
										if (coordinatej > 10)
										{
											rand = coordinatej - 10;
											coordinatej = 10;
										}
										else
											rand = 0;
									}
									if ((coordinatei < 9) && (coordinatej == 10)) //player3 fourth movement
									{
										coordinatei += rand;
										if (coordinatei > 9)
										{
											rand = coordinatei - 9;
											coordinatei = 9;
										}
										else
											rand = 0;
									}
									if ((coordinatei == 9) && (coordinatej == 10)) //player3 entry of x
									{
										if (rand == 0)
										{
										}
										else
										{
											coordinatei -= (rand - 1);
										}
										coordinatej -= rand;
										if (coordinatei < 5)
										{
											coordinatei = 10 - coordinatei;
											coordinatej = 10 - coordinatej;
										}
										rand = 0;
									}
									if ((coordinatei > 5) && (coordinatei <= 9) && (coordinatej > 5) && (coordinatej <= 9)) //player3 X return
									{
										coordinatei -= rand;
										coordinatej -= rand;
										if (coordinatei < 5)
										{
											coordinatei = 10 - coordinatei;
											coordinatej = 10 - coordinatej;
											if (coordinatei == 10)
											{
												coordinatei--;
											}
										}
										rand = 0;
									}
								} while (rand > 0);


								for (int c = 0; c < 4; c++)
								{
									if ((p[2].showchessi(c) == coordinatei) && (p[2].showchessj(c) == coordinatej) && (p[2].showlocal(c) == 2) && (p[2].showchess(c) != p[2].showchess(b))) //check team chess location
										invalid++;
								}
								if (invalid == 0)
								{
									p[2].storelocali(b, coordinatei);
									p[2].storelocalj(b, coordinatej); //store the valid coordinate
									valid[vcount] = p[2].showchess(b);
									vcount++;
								}
							}
							else if ((p[2].showlocal(b) == 0) && (rand == 6))
							{
								int coordinatei = 10;
								int coordinatej = 10;
								for (int c = 0; c < 4; c++)
								{
									if ((p[2].showchessi(c) == coordinatei) && (p[2].showchessj(c) == coordinatej) && (p[2].showlocal(c) == 2) && (p[2].showchess(c) != p[2].showchess(b))) //check team chess location
										invalid++;
								}
								if (invalid == 0)
								{
									p[2].storelocali(b, coordinatei);
									p[2].storelocalj(b, coordinatej); //store the valid coordinate
									valid[vcount] = p[2].showchess(b);
									vcount++;
								}
							}
							else
							{
								invalid++;
							}

						}

						int Error = 1;

						if (vcount == 0) //no valid move
						{
							cout << "No possible move. Pass to next player." << endl;
							displayF++;
							system("pause");
							system("cls");
							break;
						}
						else
						{
							do
							{
								if (p[turn - 1].showplayertype() == 1)
								{
									cout << "input q to exit to game menu" << endl << endl;
								}
								cout << "Choose a chess to move: ";
								for (int i = 0; i < vcount; i++)
								{
									cout << valid[i] << " ";//show the movable chess
								}
								cout << endl;

								if (p[2].showplayertype() == 1) //if player is human
								{
									cout << "? ";
									cin >> chess;
									if (chess == 'q') //command q
									{
										char x;//input validation check
										do
										{
											cout << "Are you sure to leave the game? (Y/N):";
											cin >> x;
											if (x == 'y' || x == 'Y')
											{
												return;
											}
											else if (x == 'N' || x == 'n')
											{
												system("cls");
												for (int i = 0; i < 11; i++)  //display board
												{
													for (int j = 0; j < 11; j++)
														cout << gen[i][j] << " ";
													cout << endl;
												}
												cout << "You get: " << r << endl;
												cout << "Choose a chess to move: ";
												for (int i = 0; i < vcount; i++)
												{
													cout << valid[i] << " ";//show the movable chess
												}
												cout << endl;
												cout << "? ";
												cin >> chess;
												continue;
											}

											else
											{
												system("cls");
												invalid();
												x = 'p';
											}
										} while (x == 'p');
									}
									for (int i = 0; i < vcount; i++)
									{
										if (valid[i] == chess) //check whether the chess is movable
										{
											Error = 0; //no input error
											for (int j = 0; j < 4; j++)
											{

												if (chess == p[2].showchess(j)) //found the chess in player array  
												{
													if (p[2].showlocal(j) == 0) //case for chess at base
													{
														p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
														if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
														}
														else
														{
															for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);//assign new board location for chess
														}
													}

													else	//case for chess on board
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = '.';	//let the current position of chess be .
														p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

														if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
														}
														else
														{
															if (p[2].showlocal(j) == 1) //finish home
															{
															}
															else
															{
																for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);	//assign new board location for chess
															}



														}
													}

												}
											}
										}

									}
									if (Error == 1)
									{
										invalid();
										for (int i = 0; i < 11; i++)  //display board
										{
											for (int j = 0; j < 11; j++)
												cout << gen[i][j] << " ";
											cout << endl;
										}cout << "You get: " << r << endl;
									}
								}
								else //if player is comp
								{
									chess = valid[rand() % vcount];
									cout << "Computer chooses chess " << chess << endl << endl;
									for (int i = 0; i < vcount; i++)
									{
										if (valid[i] == chess) //check whether the chess is movable
										{
											Error = 0; //no input error
											for (int j = 0; j < 4; j++)
											{

												if (chess == p[2].showchess(j)) //found the chess in player array  
												{
													if (p[2].showlocal(j) == 0) //case for chess at base
													{
														p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
														if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
														}
														else
														{
															for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);//assign new board location for chess
														}
													}

													else	//case for chess on board
													{
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = '.';	//let the current position of chess be .
														p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

														if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
														{
															gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
														}
														else
														{
															if (p[2].showlocal(j) == 1) //finish home
															{
															}
															else
															{
																for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);	//assign new board location for chess
															}



														}
													}

												}
											}
										}

									}
								}

							} while (Error == 1);
							break;
						}






					}
				}
				case 4: //player 4 
				{
					{
						{	//program for movable chess check
							for (int b = 0; b < 4; b++)
							{
								int rand = r;
								int invalid = 0;
								if ((p[3].showlocal(b) == 2)) //first valid check
								{
									int coordinatei = p[3].showchessi(b);
									int coordinatej = p[3].showchessj(b);
									do
									{
										if ((coordinatei <= 11) && (coordinatej == 0)) //player4 first movement
										{
											coordinatei -= rand;

											if (coordinatei < 0)
											{
												rand = -coordinatei;
												coordinatei = 0;
											}
											else
											{
												rand = 0;
											}
										}
										if ((coordinatei == 0) && (coordinatej < 10)) //player4 second movement
										{
											coordinatej += rand;
											if (coordinatej > 10)
											{
												rand = coordinatej - 10;
												coordinatej = 10;
											}
											else
												rand = 0;
										}
										if ((coordinatei < 10) && (coordinatej == 10)) //player4 third movement
										{
											coordinatei += rand;
											if (coordinatei > 10)
											{
												rand = coordinatei - 10;
												coordinatei = 10;
											}
											else
												rand = 0;
										}
										if ((coordinatei == 10) && (coordinatej <= 10) && (coordinatej > 1)) //player4 fourth movement
										{
											coordinatej -= rand;
											if (coordinatej < 1)
											{
												if (coordinatej < 0)
												{
													rand = -coordinatej + 1;
													coordinatej = 1;
												}
												else
												{
													rand = 1;
													coordinatej = 1;
												}
											}
											else
												rand = 0;
										}

										if ((coordinatei == 10) && (coordinatej == 1)) //player4 entry of x
										{
											coordinatei -= rand;
											if (rand == 0)
											{
											}
											else
											{
												coordinatej += (rand - 1);
											}
											if (coordinatei < 5)
											{
												coordinatei = 10 - coordinatei;
												coordinatej = 10 - coordinatej;
											}
											rand = 0;
										}
										if ((coordinatei > 5) && (coordinatei <= 9) && (coordinatej < 5) && (coordinatej >= 1)) //player4 X return
										{
											coordinatei -= rand;
											coordinatej += rand;
											if (coordinatei < 5)
											{
												coordinatei = 10 - coordinatei;
												coordinatej = 10 - coordinatej;
												if (coordinatei == 10)
												{
													coordinatej++;
												}
											}
											rand = 0;
										}
									} while (rand > 0);


									for (int c = 0; c < 4; c++)
									{
										if ((p[3].showchessi(c) == coordinatei) && (p[3].showchessj(c) == coordinatej) && (p[3].showlocal(c) == 2) && (p[3].showchess(c) != p[3].showchess(b))) //check team chess location
											invalid++;
									}
									if (invalid == 0)
									{
										p[3].storelocali(b, coordinatei);
										p[3].storelocalj(b, coordinatej); //store the valid coordinate
										valid[vcount] = p[3].showchess(b);
										vcount++;
									}
								}
								else if ((p[3].showlocal(b) == 0) && (rand == 6))
								{
									int coordinatei = 10;
									int coordinatej = 0;
									for (int c = 0; c < 4; c++)
									{
										if ((p[3].showchessi(c) == coordinatei) && (p[3].showchessj(c) == coordinatej) && (p[3].showlocal(c) == 2) && (p[3].showchess(c) != p[3].showchess(b))) //check team chess location
											invalid++;
									}
									if (invalid == 0)
									{
										p[3].storelocali(b, coordinatei);
										p[3].storelocalj(b, coordinatej); //store the valid coordinate
										valid[vcount] = p[3].showchess(b);
										vcount++;
									}
								}
								else
								{
									invalid++;
								}

							}

							int Error = 1;

							if (vcount == 0) //no valid move
							{
								cout << "No possible move. Pass to next player." << endl;
								displayF++;
								system("pause");
								system("cls");
								break;
							}
							else
							{
								do
								{
									if (p[turn - 1].showplayertype() == 1)
									{
										cout << "input q to exit to game menu" << endl << endl;
									}
									cout << "Choose a chess to move: ";
									for (int i = 0; i < vcount; i++)
									{
										cout << valid[i] << " ";//show the movable chess
									}
									cout << endl;

									if (p[3].showplayertype() == 1) //if player is human
									{
										cout << "? ";
										cin >> chess;
										if (chess == 'q') //command q
										{
											char x;//input validation check
											do
											{
												cout << "Are you sure to leave the game? (Y/N):";
												cin >> x;
												if (x == 'y' || x == 'Y')
												{
													return;
												}
												else if (x == 'N' || x == 'n')
												{
													system("cls");
													for (int i = 0; i < 11; i++)  //display board
													{
														for (int j = 0; j < 11; j++)
															cout << gen[i][j] << " ";
														cout << endl;
													}
													cout << "You get: " << r << endl;
													cout << "Choose a chess to move: ";
													for (int i = 0; i < vcount; i++)
													{
														cout << valid[i] << " ";//show the movable chess
													}
													cout << endl;
													cout << "? ";
													cin >> chess;
													continue;
												}

												else
												{
													system("cls");
													invalid();
													x = 'p';
												}
											} while (x == 'p');
										}
										for (int i = 0; i < vcount; i++)
										{
											if (valid[i] == chess) //check whether the chess is movable
											{
												Error = 0; //no input error
												for (int j = 0; j < 4; j++)
												{

													if (chess == p[3].showchess(j)) //found the chess in player array  
													{
														if (p[3].showlocal(j) == 0) //case for chess at base
														{
															p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
															if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
															{
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
															}
															else
															{

																for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);//assign new board location for chess
															}
														}

														else	//case for chess on board
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = '.';	//let the current position of chess be .
															p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

															if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
															{
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
															}
															else
															{
																if (p[3].showlocal(j) == 1) //finish home
																{
																}
																else
																{

																	for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
																	{
																		for (int L = 0; L < 4; L++)
																		{
																			if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																			{
																				p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																				cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																			}
																		}
																	}
																	gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);	//assign new board location for chess
																}



															}
														}

													}
												}
											}

										}
										if (Error == 1)
										{
											invalid();
											for (int i = 0; i < 11; i++)  //display board
											{
												for (int j = 0; j < 11; j++)
													cout << gen[i][j] << " ";
												cout << endl;
											}cout << "You get: " << r << endl;
										}
									}
									else //if player is comp
									{
										chess = valid[rand() % vcount];
										cout << "Computer chooses chess " << chess << endl << endl;
										for (int i = 0; i < vcount; i++)
										{
											if (valid[i] == chess) //check whether the chess is movable
											{
												Error = 0; //no input error
												for (int j = 0; j < 4; j++)
												{

													if (chess == p[3].showchess(j)) //found the chess in player array  
													{
														if (p[3].showlocal(j) == 0) //case for chess at base
														{
															p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
															if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
															{
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
															}
															else
															{

																for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
																{
																	for (int L = 0; L < 4; L++)
																	{
																		if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																		{
																			p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																			cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																		}
																	}
																}
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);//assign new board location for chess
															}
														}

														else	//case for chess on board
														{
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = '.';	//let the current position of chess be .
															p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

															if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
															{
																gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
															}
															else
															{
																if (p[3].showlocal(j) == 1) //finish home
																{
																}
																else
																{

																	for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
																	{
																		for (int L = 0; L < 4; L++)
																		{
																			if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																			{
																				p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																				cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																			}
																		}
																	}
																	gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);	//assign new board location for chess
																}



															}
														}

													}
												}
											}

										}
									}

								} while (Error == 1);
								break;
							}






						}
					}
				}
				}
				for (int w = 0; w < 4; w++) //check winner and display winner message
				{
					if (p[w].showwin() == 4)
					{
						system("pause");
						system("cls");
						cout << "The winner is player " << w + 1 << " !! Congratulation!!!" << endl;
						winner++;
						return;
					}

				}
				if ((countsix < 2) && (r == 6))
				{
					cout << endl << "Player " << turn << " get a 6 for " << countsix + 1 << " time[s]. There is a bonus round." << endl << endl;
					system("pause");
					system("cls");
					countsix++;
				}
				else
				{
					if (displayF == 0)
					{
						cout << "No more bonus move. Pass to next player." << endl;
						system("pause");
					}
					turn = turn % 2 + 1; //pass to next turn
					countsix = 0;
					system("cls");
				}
				countturn++;
				if (countturn == 4)
				{
					return;
				}
			} while (winner == 0);
		}
	}
}

void start_game()// Main Game
{
	srand(time(0));
	player p[4];
	int a = numofHP; //get the number of human player
	int countsix = 0;//roll 6 counter
	int turn = 1; //which player's turn
	int winner = 0;
	p[0].assignchess('a', 'b', 'c', 'd');
	p[1].assignchess('e', 'f', 'g', 'h');
	p[2].assignchess('i', 'j', 'k', 'l');
	p[3].assignchess('m', 'n', 'o', 'p');
	p[0].assignbase(0, -1);
	p[1].assignbase(-1, 10);
	p[2].assignbase(10, 11);
	p[3].assignbase(11, 0);
	for (int i = 0; i < 4; i++) //initial chess location (i is NO. of chess)
	{
		p[0].assignlocal(i, 0, -1);
		p[1].assignlocal(i, -1, 10);
		p[2].assignlocal(i, 10, 11);
		p[3].assignlocal(i, 11, 0);
	}
	char gen[12][12] = { "...........","..       ..",". .     . .",".  .   .  .",".   . .   .",".    X    .",".   . .   .",".  .   .  .",". .     . .","..       ..","..........." };
	int r;

	for (int k = 0; k < numofTP; k++) //assign playertype according to numofHP & numofTP
	{
		if (a > 0)
		{
			p[k].assignplayertype(1);
			a--;
		}
		else
		{
			p[k].assignplayertype(0);
		}
	}

	do //start game looping
	{
		for (int i = 0; i < 11; i++)  //display board
		{
			for (int j = 0; j < 11; j++)
				cout << gen[i][j] << " ";
			cout << endl;
		}
		for (int i = 0; i < numofTP; i++) // Player type (HUM/COM)
		{
			int pt;
			pt = p[i].showplayertype();
			cout << "Player " << (i + 1) << ": ";
			if (pt == 0)
			{
				cout << "COMP";
			}
			else
			{
				cout << "Human";
			}
			cout << endl << "Base: ";
			for (int j = 0; j < 4; j++)
			{
				if (p[i].showlocal(j) == 0) //chess in base
				{
					cout << p[i].showchess(j) << " ";
				}
			}
			cout << endl << "Home: ";
			for (int j = 0; j < 4; j++)
			{
				if (p[i].showlocal(j) == 1) //chess at home
				{
					cout << p[i].showchess(j) << " ";
				}
			}
			cout << endl << endl;

		}
		//r = 6;
		r = randnum(); //roll number
		cout << "Player " << turn << "'s turn ... Rolling. You get: " << r << endl;

		int vcount = 0;
		int displayF = 0;
		char chess;
		char valid[4]; //copy the chess which is movable

		switch (turn)
		{
		case 1://player 1
		{	//program for movable chess check
			for (int b = 0; b < 4; b++)
			{
				int rand = r;
				int invalid = 0;
				if ((p[0].showlocal(b) == 2)) //first valid check
				{
					int coordinatei = p[0].showchessi(b);
					int coordinatej = p[0].showchessj(b);
					do
					{
						if ((coordinatei == 0) && (coordinatej < 10)) //player1 first movement
						{
							coordinatej += rand;
							if (coordinatej > 10)
							{
								rand = coordinatej - 10;
								coordinatej = 10;
							}
							else
								rand = 0;
						}
						if ((coordinatei < 10) && (coordinatej == 10)) //player1 second movement
						{
							coordinatei += rand;
							if (coordinatei > 10)
							{
								rand = coordinatei - 10;
								coordinatei = 10;
							}
							else
								rand = 0;
						}
						if ((coordinatei == 10) && (coordinatej <= 10)) //player1 third movement
						{
							coordinatej -= rand;
							if (coordinatej < 0)
							{
								rand = -coordinatej;
								coordinatej = 0;
							}
							else
								rand = 0;
						}
						if ((coordinatei <= 10) && (coordinatej == 0) && (coordinatei > 1)) //player1 fourth movement
						{
							coordinatei -= rand;
							if (coordinatei < 1)
							{
								if (coordinatei < 0)
								{
									rand = -coordinatei + 1;
									coordinatei = 1;
								}
								else
								{
									rand = 1;
									coordinatei = 1;
								}
							}
							else
							{
								rand = 0;
							}
						}
						if ((coordinatei == 1) && (coordinatej == 0)) //player1 entry of x
						{
							if (rand == 0)
							{

							}
							else
							{
								coordinatei += rand - 1;
							}
							coordinatej += rand;
							if (coordinatei > 5)
							{
								coordinatei = 10 - coordinatei;
								coordinatej = 10 - coordinatej;
							}
							rand = 0;
						}
						if ((coordinatei >= 1) && (coordinatei < 5) && (coordinatej >= 1) && (coordinatej < 5)) //player1 X return
						{
							coordinatei += rand;
							coordinatej += rand;
							if (coordinatei > 5)
							{
								coordinatei = 10 - coordinatei;
								coordinatej = 10 - coordinatej;
								if (coordinatei == 0)
								{
									coordinatei++;
								}
							}
							rand = 0;
						}
					} while (rand > 0);


					for (int c = 0; c < 4; c++)
					{
						if ((p[0].showchessi(c) == coordinatei) && (p[0].showchessj(c) == coordinatej) && (p[0].showlocal(c) == 2) && (p[0].showchess(c) != p[0].showchess(b))) //check team chess location
							invalid++;
					}
					if (invalid == 0)
					{
						p[0].storelocali(b, coordinatei);
						p[0].storelocalj(b, coordinatej); //store the valid coordinate
						valid[vcount] = p[0].showchess(b);
						vcount++;
					}
				}
				else if ((p[0].showlocal(b) == 0) && (rand == 6)) //valid check for chess at base
				{
					int coordinatei = 0;
					int coordinatej = 0;

					for (int c = 0; c < 4; c++)
					{
						if ((p[0].showchessi(c) == coordinatei) && (p[0].showchessj(c) == coordinatej) && (p[0].showlocal(c) == 2) && (p[0].showchess(c) != p[0].showchess(b))) //check team chess location
							invalid++;
					}
					if (invalid == 0)
					{
						p[0].storelocali(b, coordinatei);
						p[0].storelocalj(b, coordinatej); //store the valid coordinate
						valid[vcount] = p[0].showchess(b);
						vcount++;
					}
				}
				else
				{
					invalid++;
				}

			}

			int Error = 1; //invalid input check

			if (vcount == 0) //no valid move
			{
				cout << "No possible move. Pass to next player." << endl;
				displayF++;
				system("pause");
				system("cls");
				break;
			}
			else
			{
				do
				{
					if (p[turn - 1].showplayertype() == 1)
					{
						cout << "input q to exit to game menu" << endl << endl;
					}
					cout << "Choose a chess to move: ";
					for (int i = 0; i < vcount; i++)
					{
						cout << valid[i] << " ";//show the movable chess
					}
					cout << endl;

					if (p[0].showplayertype() == 1) //if player is human
					{
						cout << "? ";
						chess = validcheck();
						if (chess == 'q') //command q
						{
							char x;//input validation check
							do
							{
								cout << "Are you sure to leave the game? (Y/N):";
								x = validcheck();
								if (x == 'y' || x == 'Y')
								{
									return;
								}
								else if (x == 'N' || x == 'n')
								{
									system("cls");
									for (int i = 0; i < 11; i++)  //display board
									{
										for (int j = 0; j < 11; j++)
											cout << gen[i][j] << " ";
										cout << endl;
									}
									cout << "You get: " << r << endl;
									cout << "Choose a chess to move: ";
									for (int i = 0; i < vcount; i++)
									{
										cout << valid[i] << " ";//show the movable chess
									}
									cout << endl;
									cout << "? ";
									x = validcheck();
									continue;
								}

								else
								{
									system("cls");
									invalid();
									x = 'p';
								}
							} while (x == 'p');
						}
						for (int i = 0; i < vcount; i++)
						{
							if (valid[i] == chess) //check whether the chess is movable
							{
								Error = 0; //no input error
								for (int j = 0; j < 4; j++)
								{

									if (chess == p[0].showchess(j)) //found the chess in player array  
									{
										if (p[0].showlocal(j) == 0) //case for chess at base
										{
											p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
											if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
											{
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
											}
											else
											{
												for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
												{
													for (int L = 0; L < 4; L++)
													{
														if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
														{
															p[m].assignlocal(L, p[m].showini(), p[m].showinj());//assign the eaten chess back to base
															cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
														}
													}
												}
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);//assign new board location for chess
											}
										}

										else	//case for chess on board
										{
											gen[p[0].showchessi(j)][p[0].showchessj(j)] = '.';	//let the current position of chess be .
											p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

											if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
											{
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
											}
											else
											{
												if (p[0].showlocal(j) == 1) //finish home
												{
												}
												else
												{
													for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);	//assign new board location for chess
												}



											}
										}

									}
								}
							}

						}
						if (Error == 1)
						{
							invalid();
							for (int i = 0; i < 11; i++)  //display board
							{
								for (int j = 0; j < 11; j++)
									cout << gen[i][j] << " ";
								cout << endl;
							}cout << "You get: " << r << endl;
						}
					}
					else //if player is comp
					{
						chess = valid[rand() % vcount];
						cout << "Computer chooses chess " << chess << endl << endl;

						for (int i = 0; i < vcount; i++)
						{
							Error = 0; //no input error
							if (valid[i] == chess) //check whether the chess is movable
							{
								for (int j = 0; j < 4; j++)
								{

									if (chess == p[0].showchess(j)) //found the chess in player array  
									{
										if (p[0].showlocal(j) == 0) //case for chess at base
										{
											p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
											if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
											{
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
											}
											else
											{
												for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
												{
													for (int L = 0; L < 4; L++)
													{
														if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
														{
															p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
															cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
														}
													}
												}
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);//assign new board location for chess
											}
										}

										else	//case for chess on board
										{
											gen[p[0].showchessi(j)][p[0].showchessj(j)] = '.';	//let the current position of chess be .
											p[0].assignlocal(j, p[0].showslocali(j), p[0].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

											if (gen[p[0].showchessi(j)][p[0].showchessj(j)] == '.') //if no chess in next location
											{
												gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j); //assign new board location for chess
											}
											else
											{
												if (p[0].showlocal(j) == 1) //finish home
												{
												}
												else
												{
													for (int m = 1; m < 4; m++) //find the chess that been ate in player 2-4
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[0].showchessi(j)][p[0].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[0].showchessi(j)][p[0].showchessj(j)] = p[0].showchess(j);	//assign new board location for chess
												}



											}
										}

									}
								}
							}

						}

					}

				} while (Error == 1);
				break;
			}






		}
		case 2: //player 2
		{ {	//program for movable chess check
				for (int b = 0; b < 4; b++)
				{
					int rand = r;
					int invalid = 0;
					if ((p[1].showlocal(b) == 2)) //start flight (first valid check)
					{
						int coordinatei = p[1].showchessi(b);
						int coordinatej = p[1].showchessj(b);
						do
						{
							if ((coordinatei < 10) && (coordinatej == 10)) //player2 first movement
							{
								coordinatei += rand;
								if (coordinatei > 10)
								{
									rand = coordinatei - 10;
									coordinatei = 10;
								}
								else
									rand = 0;
							}
							if ((coordinatei == 10) && (coordinatej <= 10)) //player2 second movement
							{
								coordinatej -= rand;
								if (coordinatej < 0)
								{
									rand = -coordinatej;
									coordinatej = 0;
								}
								else
									rand = 0;
							}
							if ((coordinatei <= 10) && (coordinatej == 0)) //player2 third movement
							{
								coordinatei -= rand;

								if (coordinatei < 0)
								{
									rand = -coordinatei;
									coordinatei = 0;
								}
								else
								{
									rand = 0;
								}
							}
							if ((coordinatei == 0) && (coordinatej < 9)) //player2 fourth movement
							{
								coordinatej += rand;
								if (coordinatej > 9)
								{
									rand = (coordinatej - 9);
									coordinatej = 9;
								}
								else
									rand = 0;
							}



							if ((coordinatei == 0) && (coordinatej == 9)) //player2 entry of x 
							{
								coordinatei += rand;
								if (rand == 0)
								{
								}
								else
								{
									coordinatej -= (rand - 1);
								}
								if (coordinatei > 5)
								{
									coordinatei = 10 - coordinatei;
									coordinatej = 10 - coordinatej;
								}
								rand = 0;
							}
							if ((coordinatei >= 1) && (coordinatei < 5) && (coordinatej <= 9) && (coordinatej > 5)) //player2 X return
							{
								coordinatei += rand;
								coordinatej -= rand;
								if (coordinatei > 5)
								{
									coordinatei = 10 - coordinatei;
									coordinatej = 10 - coordinatej;
									if (coordinatej == 10)
									{
										coordinatej--;
									}
								}
								rand = 0;
							}
						} while (rand > 0);


						for (int c = 0; c < 4; c++)//check team chess location
						{
							if ((p[1].showchessi(c) == coordinatei) && (p[1].showlocal(c) == 2) && (p[1].showchessj(c) == coordinatej) && (p[1].showchess(c) != p[1].showchess(b)))
								invalid++;
						}
						if (invalid == 0)
						{
							p[1].storelocali(b, coordinatei);
							p[1].storelocalj(b, coordinatej); //store the valid coordinate
							valid[vcount] = p[1].showchess(b);
							vcount++;
						}
					}
					else if ((p[1].showlocal(b) == 0) && (rand == 6))
					{
						int coordinatei = 0;
						int coordinatej = 10;
						for (int c = 0; c < 4; c++)//check team chess location
						{
							if ((p[1].showchessi(c) == coordinatei) && (p[1].showlocal(c) == 2) && (p[1].showchessj(c) == coordinatej) && (p[1].showchess(c) != p[1].showchess(b)))
								invalid++;
						}
						if (invalid == 0)
						{
							p[1].storelocali(b, coordinatei);
							p[1].storelocalj(b, coordinatej); //store the valid coordinate
							valid[vcount] = p[1].showchess(b);
							vcount++;
						}
					}
					else
					{
						invalid++;
					}

				}

				int Error = 1;

				if (vcount == 0) //no valid move
				{
					cout << "No possible move. Pass to next player." << endl;
					displayF++;
					system("pause");
					system("cls");
					break;
				}
				else
				{
					do
					{
						if (p[turn - 1].showplayertype() == 1)
						{
							cout << "input q to exit to game menu" << endl << endl;
						}
						cout << "Choose a chess to move: ";
						for (int i = 0; i < vcount; i++)
						{
							cout << valid[i] << " ";//show the movable chess
						}
						cout << endl;

						if (p[1].showplayertype() == 1) //if player is human
						{
							cout << "? ";
							chess=validcheck();
							if (chess == 'q') //command q
							{
								char x;//input validation check
								do
								{
									cout << "Are you sure to leave the game? (Y/N):";
									x = validcheck();
									if (x == 'y' || x == 'Y')
									{
										return;
									}
									else if (x == 'N' || x == 'n')
									{
										system("cls");
										for (int i = 0; i < 11; i++)  //display board
										{
											for (int j = 0; j < 11; j++)
												cout << gen[i][j] << " ";
											cout << endl;
										}
										cout << "You get: " << r << endl;
										cout << "Choose a chess to move: ";
										for (int i = 0; i < vcount; i++)
										{
											cout << valid[i] << " ";//show the movable chess
										}
										cout << endl;
										cout << "? ";
										chess = validcheck();
										continue;
									}

									else
									{
										system("cls");
										invalid();
										x = 'p';
									}
								} while (x == 'p');
							}
							for (int i = 0; i < vcount; i++)
							{
								if (valid[i] == chess) //check whether the input chess is movable
								{
									Error = 0; //no input error
									for (int j = 0; j < 4; j++)
									{

										if (chess == p[1].showchess(j)) //found the chess in player array  
										{
											if (p[1].showlocal(j) == 0) //case for chess at base
											{
												p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
												if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
												}
												else
												{
													for (int l = 0; l < 4; l++) //check player 1 chess
													{
														if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
														{
															p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
															cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
														}
													}
													for (int m = 2; m < 4; m++) //check player 3 and 4 chess
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
												}
											}

											else	//case for chess on board
											{
												gen[p[1].showchessi(j)][p[1].showchessj(j)] = '.';	//let the current position of chess be .
												p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

												if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
												}
												else
												{
													if (p[1].showlocal(j) == 1) //finish home
													{
													}
													else
													{
														for (int l = 0; l < 4; l++) //check player 1 chess
														{
															if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
															{
																p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
															}
														}
														for (int m = 2; m < 4; m++) //check player 3 and 4 chess
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
													}



												}
											}

										}
									}
								}
							}
							if (Error == 1)
							{
								invalid();
								for (int i = 0; i < 11; i++)  //display board
								{
									for (int j = 0; j < 11; j++)
										cout << gen[i][j] << " ";
									cout << endl;
								}cout << "You get: " << r << endl;
							}
						}
						else //if player is comp
						{
							chess = valid[rand() % vcount];
							cout << "Computer chooses chess " << chess << endl << endl;
							for (int i = 0; i < vcount; i++)
							{
								if (valid[i] == chess) //check whether the input chess is movable
								{
									Error = 0; //no input error
									for (int j = 0; j < 4; j++)
									{

										if (chess == p[1].showchess(j)) //found the chess in player array  
										{
											if (p[1].showlocal(j) == 0) //case for chess at base
											{
												p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
												if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
												}
												else
												{
													for (int l = 0; l < 4; l++) //check player 1 chess
													{
														if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
														{
															p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
															cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
														}
													}
													for (int m = 2; m < 4; m++) //check player 3 and 4 chess
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
												}
											}

											else	//case for chess on board
											{
												gen[p[1].showchessi(j)][p[1].showchessj(j)] = '.';	//let the current position of chess be .
												p[1].assignlocal(j, p[1].showslocali(j), p[1].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

												if (gen[p[1].showchessi(j)][p[1].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j); //assign new board location for chess
												}
												else
												{
													if (p[1].showlocal(j) == 1) //finish home
													{
													}
													else
													{
														for (int l = 0; l < 4; l++) //check player 1 chess
														{
															if (p[0].showchess(l) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
															{
																p[0].assignlocal(l, p[0].showini(), p[0].showinj());//assign the eaten chess back to base
																cout << endl << "Chess " << p[0].showchess(l) << " have been captured!" << endl;
															}
														}
														for (int m = 2; m < 4; m++) //check player 3 and 4 chess
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[1].showchessi(j)][p[1].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[1].showchessi(j)][p[1].showchessj(j)] = p[1].showchess(j);	//assign new board location for chess
													}



												}
											}

										}
									}
								}
							}

						}

					} while (Error == 1);
					break;
				}






			}
		}
		case 3://player 3
		{
			{	//program for movable chess check
				for (int b = 0; b < 4; b++)
				{
					int rand = r;
					int invalid = 0;
					if ((p[2].showlocal(b) == 2)) //first valid check
					{
						int coordinatei = p[2].showchessi(b);
						int coordinatej = p[2].showchessj(b);
						do
						{
							if ((coordinatei == 10) && (coordinatej <= 11) && (coordinatej > 0)) //player3 first movement
							{
								coordinatej -= rand;
								if (coordinatej < 0)
								{
									rand = -coordinatej;
									coordinatej = 0;
								}
								else
									rand = 0;
							}
							if ((coordinatei <= 10) && (coordinatej == 0)) //player3 second movement
							{
								coordinatei -= rand;

								if (coordinatei < 0)
								{
									rand = -coordinatei;
									coordinatei = 0;
								}
								else
								{
									rand = 0;
								}
							}
							if ((coordinatei == 0) && (coordinatej < 10)) //player3 third movement
							{
								coordinatej += rand;
								if (coordinatej > 10)
								{
									rand = coordinatej - 10;
									coordinatej = 10;
								}
								else
									rand = 0;
							}
							if ((coordinatei < 9) && (coordinatej == 10)) //player3 fourth movement
							{
								coordinatei += rand;
								if (coordinatei > 9)
								{
									rand = coordinatei - 9;
									coordinatei = 9;
								}
								else
									rand = 0;
							}
							if ((coordinatei == 9) && (coordinatej == 10)) //player3 entry of x
							{
								if (rand == 0)
								{
								}
								else
								{
									coordinatei -= (rand - 1);
								}
								coordinatej -= rand;
								if (coordinatei < 5)
								{
									coordinatei = 10 - coordinatei;
									coordinatej = 10 - coordinatej;
								}
								rand = 0;
							}
							if ((coordinatei > 5) && (coordinatei <= 9) && (coordinatej > 5) && (coordinatej <= 9)) //player3 X return
							{
								coordinatei -= rand;
								coordinatej -= rand;
								if (coordinatei < 5)
								{
									coordinatei = 10 - coordinatei;
									coordinatej = 10 - coordinatej;
									if (coordinatei == 10)
									{
										coordinatei--;
									}
								}
								rand = 0;
							}
						} while (rand > 0);


						for (int c = 0; c < 4; c++)
						{
							if ((p[2].showchessi(c) == coordinatei) && (p[2].showchessj(c) == coordinatej) && (p[2].showlocal(c) == 2) && (p[2].showchess(c) != p[2].showchess(b))) //check team chess location
								invalid++;
						}
						if (invalid == 0)
						{
							p[2].storelocali(b, coordinatei);
							p[2].storelocalj(b, coordinatej); //store the valid coordinate
							valid[vcount] = p[2].showchess(b);
							vcount++;
						}
					}
					else if ((p[2].showlocal(b) == 0) && (rand == 6))
					{
						int coordinatei = 10;
						int coordinatej = 10;
						for (int c = 0; c < 4; c++)
						{
							if ((p[2].showchessi(c) == coordinatei) && (p[2].showchessj(c) == coordinatej) && (p[2].showlocal(c) == 2) && (p[2].showchess(c) != p[2].showchess(b))) //check team chess location
								invalid++;
						}
						if (invalid == 0)
						{
							p[2].storelocali(b, coordinatei);
							p[2].storelocalj(b, coordinatej); //store the valid coordinate
							valid[vcount] = p[2].showchess(b);
							vcount++;
						}
					}
					else
					{
						invalid++;
					}

				}

				int Error = 1;

				if (vcount == 0) //no valid move
				{
					cout << "No possible move. Pass to next player." << endl;
					displayF++;
					system("pause");
					system("cls");
					break;
				}
				else
				{
					do
					{
						if (p[turn - 1].showplayertype() == 1)
						{
							cout << "input q to exit to game menu" << endl << endl;
						}
						cout << "Choose a chess to move: ";
						for (int i = 0; i < vcount; i++)
						{
							cout << valid[i] << " ";//show the movable chess
						}
						cout << endl;

						if (p[2].showplayertype() == 1) //if player is human
						{
							cout << "? ";
							chess=validcheck();
							if (chess == 'q') //command q
							{
								char x;//input validation check
								do
								{
									cout << "Are you sure to leave the game? (Y/N):";
									x = validcheck();
									if (x == 'y' || x == 'Y')
									{
										return;
									}
									else if (x == 'N' || x == 'n')
									{
										system("cls");
										for (int i = 0; i < 11; i++)  //display board
										{
											for (int j = 0; j < 11; j++)
												cout << gen[i][j] << " ";
											cout << endl;
										}
										cout << "You get: " << r << endl;
										cout << "Choose a chess to move: ";
										for (int i = 0; i < vcount; i++)
										{
											cout << valid[i] << " ";//show the movable chess
										}
										cout << endl;
										cout << "? ";
										chess = validcheck();
										continue;
									}

									else
									{
										system("cls");
										invalid();
										x = 'p';
									}
								} while (x == 'p');
							}
							for (int i = 0; i < vcount; i++)
							{
								if (valid[i] == chess) //check whether the chess is movable
								{
									Error = 0; //no input error
									for (int j = 0; j < 4; j++)
									{

										if (chess == p[2].showchess(j)) //found the chess in player array  
										{
											if (p[2].showlocal(j) == 0) //case for chess at base
											{
												p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
												if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
												}
												else
												{
													for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);//assign new board location for chess
												}
											}

											else	//case for chess on board
											{
												gen[p[2].showchessi(j)][p[2].showchessj(j)] = '.';	//let the current position of chess be .
												p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

												if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
												}
												else
												{
													if (p[2].showlocal(j) == 1) //finish home
													{
													}
													else
													{
														for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);	//assign new board location for chess
													}



												}
											}

										}
									}
								}

							}
							if (Error == 1)
							{
								invalid();
								for (int i = 0; i < 11; i++)  //display board
								{
									for (int j = 0; j < 11; j++)
										cout << gen[i][j] << " ";
									cout << endl;
								}cout << "You get: " << r << endl;
							}
						}
						else //if player is comp
						{
							chess = valid[rand() % vcount];
							cout << "Computer chooses chess " << chess << endl << endl;
							for (int i = 0; i < vcount; i++)
							{
								if (valid[i] == chess) //check whether the chess is movable
								{
									Error = 0; //no input error
									for (int j = 0; j < 4; j++)
									{

										if (chess == p[2].showchess(j)) //found the chess in player array  
										{
											if (p[2].showlocal(j) == 0) //case for chess at base
											{
												p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
												if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
												}
												else
												{
													for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
													{
														for (int L = 0; L < 4; L++)
														{
															if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
															{
																p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
															}
														}
													}
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);//assign new board location for chess
												}
											}

											else	//case for chess on board
											{
												gen[p[2].showchessi(j)][p[2].showchessj(j)] = '.';	//let the current position of chess be .
												p[2].assignlocal(j, p[2].showslocali(j), p[2].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

												if (gen[p[2].showchessi(j)][p[2].showchessj(j)] == '.') //if no chess in next location
												{
													gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j); //assign new board location for chess
												}
												else
												{
													if (p[2].showlocal(j) == 1) //finish home
													{
													}
													else
													{
														for (int m = 3; m < 4; m++) //find the chess that been ate in player 4
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														for (int m = 0; m < 2; m++) //find the chess that been ate in player 1-2
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[2].showchessi(j)][p[2].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[2].showchessi(j)][p[2].showchessj(j)] = p[2].showchess(j);	//assign new board location for chess
													}



												}
											}

										}
									}
								}

							}
						}

					} while (Error == 1);
					break;
				}






			}
		}
		case 4: //player 4 
		{
			{
				{	//program for movable chess check
					for (int b = 0; b < 4; b++)
					{
						int rand = r;
						int invalid = 0;
						if ((p[3].showlocal(b) == 2)) //first valid check
						{
							int coordinatei = p[3].showchessi(b);
							int coordinatej = p[3].showchessj(b);
							do
							{
								if ((coordinatei <= 11) && (coordinatej == 0)) //player4 first movement
								{
									coordinatei -= rand;

									if (coordinatei < 0)
									{
										rand = -coordinatei;
										coordinatei = 0;
									}
									else
									{
										rand = 0;
									}
								}
								if ((coordinatei == 0) && (coordinatej < 10)) //player4 second movement
								{
									coordinatej += rand;
									if (coordinatej > 10)
									{
										rand = coordinatej - 10;
										coordinatej = 10;
									}
									else
										rand = 0;
								}
								if ((coordinatei < 10) && (coordinatej == 10)) //player4 third movement
								{
									coordinatei += rand;
									if (coordinatei > 10)
									{
										rand = coordinatei - 10;
										coordinatei = 10;
									}
									else
										rand = 0;
								}
								if ((coordinatei == 10) && (coordinatej <= 10) && (coordinatej > 1)) //player4 fourth movement
								{
									coordinatej -= rand;
									if (coordinatej < 1)
									{
										if (coordinatej < 0)
										{
											rand = -coordinatej + 1;
											coordinatej = 1;
										}
										else
										{
											rand = 1;
											coordinatej = 1;
										}
									}
									else
										rand = 0;
								}

								if ((coordinatei == 10) && (coordinatej == 1)) //player4 entry of x
								{
									coordinatei -= rand;
									if (rand == 0)
									{
									}
									else
									{
										coordinatej += (rand - 1);
									}
									if (coordinatei < 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
									}
									rand = 0;
								}
								if ((coordinatei > 5) && (coordinatei <= 9) && (coordinatej < 5) && (coordinatej >= 1)) //player4 X return
								{
									coordinatei -= rand;
									coordinatej += rand;
									if (coordinatei < 5)
									{
										coordinatei = 10 - coordinatei;
										coordinatej = 10 - coordinatej;
										if (coordinatei == 10)
										{
											coordinatej++;
										}
									}
									rand = 0;
								}
							} while (rand > 0);


							for (int c = 0; c < 4; c++)
							{
								if ((p[3].showchessi(c) == coordinatei) && (p[3].showchessj(c) == coordinatej) && (p[3].showlocal(c) == 2) && (p[3].showchess(c) != p[3].showchess(b))) //check team chess location
									invalid++;
							}
							if (invalid == 0)
							{
								p[3].storelocali(b, coordinatei);
								p[3].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[3].showchess(b);
								vcount++;
							}
						}
						else if ((p[3].showlocal(b) == 0) && (rand == 6))
						{
							int coordinatei = 10;
							int coordinatej = 0;
							for (int c = 0; c < 4; c++)
							{
								if ((p[3].showchessi(c) == coordinatei) && (p[3].showchessj(c) == coordinatej) && (p[3].showlocal(c) == 2) && (p[3].showchess(c) != p[3].showchess(b))) //check team chess location
									invalid++;
							}
							if (invalid == 0)
							{
								p[3].storelocali(b, coordinatei);
								p[3].storelocalj(b, coordinatej); //store the valid coordinate
								valid[vcount] = p[3].showchess(b);
								vcount++;
							}
						}
						else
						{
							invalid++;
						}

					}

					int Error = 1;

					if (vcount == 0) //no valid move
					{
						cout << "No possible move. Pass to next player." << endl;
						displayF++;
						system("pause");
						system("cls");
						break;
					}
					else
					{
						do
						{
							if (p[turn - 1].showplayertype() == 1)
							{
								cout << "input q to exit to game menu" << endl << endl;
							}
							cout << "Choose a chess to move: ";
							for (int i = 0; i < vcount; i++)
							{
								cout << valid[i] << " ";//show the movable chess
							}
							cout << endl;

							if (p[3].showplayertype() == 1) //if player is human
							{
								cout << "? ";
								chess = validcheck();
								if (chess == 'q') //command q
								{
									char x;//input validation check
									do
									{
										cout << "Are you sure to leave the game? (Y/N):";
										x = validcheck();
										if (x == 'y' || x == 'Y')
										{
											return;
										}
										else if (x == 'N' || x == 'n')
										{
											system("cls");
											for (int i = 0; i < 11; i++)  //display board
											{
												for (int j = 0; j < 11; j++)
													cout << gen[i][j] << " ";
												cout << endl;
											}
											cout << "You get: " << r << endl;
											cout << "Choose a chess to move: ";
											for (int i = 0; i < vcount; i++)
											{
												cout << valid[i] << " ";//show the movable chess
											}
											cout << endl;
											cout << "? ";
											chess = validcheck();
											continue;
										}

										else
										{
											system("cls");
											invalid();
											x = 'p';
										}
									} while (x == 'p');
								}
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[3].showchess(j)) //found the chess in player array  
											{
												if (p[3].showlocal(j) == 0) //case for chess at base
												{
													p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
													}
													else
													{

														for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[3].showchessi(j)][p[3].showchessj(j)] = '.';	//let the current position of chess be .
													p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[3].showlocal(j) == 1) //finish home
														{
														}
														else
														{

															for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}

								}
								if (Error == 1)
								{
									invalid();
									for (int i = 0; i < 11; i++)  //display board
									{
										for (int j = 0; j < 11; j++)
											cout << gen[i][j] << " ";
										cout << endl;
									}cout << "You get: " << r << endl;
								}
							}
							else //if player is comp
							{
								chess = valid[rand() % vcount];
								cout << "Computer chooses chess " << chess << endl << endl;
								for (int i = 0; i < vcount; i++)
								{
									if (valid[i] == chess) //check whether the chess is movable
									{
										Error = 0; //no input error
										for (int j = 0; j < 4; j++)
										{

											if (chess == p[3].showchess(j)) //found the chess in player array  
											{
												if (p[3].showlocal(j) == 0) //case for chess at base
												{
													p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate
													if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
													}
													else
													{

														for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
														{
															for (int L = 0; L < 4; L++)
															{
																if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																{
																	p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																	cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																}
															}
														}
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);//assign new board location for chess
													}
												}

												else	//case for chess on board
												{
													gen[p[3].showchessi(j)][p[3].showchessj(j)] = '.';	//let the current position of chess be .
													p[3].assignlocal(j, p[3].showslocali(j), p[3].showslocalj(j));	//assign new x(chessi) and y(chessj) coordinate

													if (gen[p[3].showchessi(j)][p[3].showchessj(j)] == '.') //if no chess in next location
													{
														gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j); //assign new board location for chess
													}
													else
													{
														if (p[3].showlocal(j) == 1) //finish home
														{
														}
														else
														{

															for (int m = 0; m < 3; m++) //find the chess that been ate in player 1-3
															{
																for (int L = 0; L < 4; L++)
																{
																	if (p[m].showchess(L) == gen[p[3].showchessi(j)][p[3].showchessj(j)]) //eat other's chess
																	{
																		p[m].assignlocal(L, p[m].showini(), p[m].showinj()); //assign the eaten chess back to base
																		cout << endl << "Chess " << p[m].showchess(L) << " have been captured!" << endl;
																	}
																}
															}
															gen[p[3].showchessi(j)][p[3].showchessj(j)] = p[3].showchess(j);	//assign new board location for chess
														}



													}
												}

											}
										}
									}

								}
							}

						} while (Error == 1);
						break;
					}






				}
			}
		}
		}

		for (int w = 0; w < 4; w++) //check winner and display winner message
		{
			if (p[w].showwin() == 4)
			{
				system("pause");
				system("cls");
				win(w + 1);
				winner++;
				return;
			}

		}
		if ((countsix < 2) && (r == 6)) //roll 6 checker
		{
			cout << endl << "Player " << turn << " get a 6 for " << countsix + 1 << " time[s]. There is a bonus round." << endl << endl;
			system("pause");
			system("cls");
			countsix++;
		}
		else
		{
			if (displayF == 0)
			{
				cout << "No more bonus move. Pass to next player." << endl;
				system("pause");
			}
			turn = turn % numofTP + 1; //pass to next turn
			countsix = 0;
			system("cls");
		}

	} while (winner == 0);
}

void settings()
{
	int num;

	do
	{
		cout << "* Settings Menu *\n[1] Number of players\n[2] Number of human players\n[3] Return to Game Menu\n*********\nOption (1 - 3):";
		num = errorcheck();
		switch (num)
		{
		case 1:
		{

			system("cls");
			int x, k, y;

			if (numofHP <= 2)
			{
				y = 2;
			}
			else
			{
				y = numofHP;
			}
			do {

				cout << "Current setting - No. of player is " << numofTP << " \nInput new value (" << y << "-4):";
				x = errorcheck();
				system("cls");
				if (x <= 4 && x >= numofHP && x >= 2)
				{
					numofTP = x;
					k = 1;
				}
				else
				{
					k = 0;
					invalid();
				}

			} while (k != 1);

			cout << "Update done, current No. of player is " << numofTP << endl;
			system("pause");
			system("cls");
			continue;
		}
		case 2:
		{
			system("cls");

			int y, k;
			do
			{
				cout << "Current setting - No. of human player is " << numofHP << " \nInput new value (0-" << numofTP << "):";
				y = errorcheck();
				system("cls");
				if (y >= 0 && y <= numofTP && y <= 4)
				{
					numofHP = y;
					k = 1;
				}
				else
				{
					k = 0;
					invalid();
				}
			} while (k != 1);

			cout << "Update done, current No. of human player is " << numofHP << endl;
			system("pause");
			system("cls");
			continue;
		}
		case 3:
		{
			return;
		}
		default:
		{
			invalid();
		}
		}
	} while (num != 3);
}

void demo()// Demo menu
{

	int num;

	do
	{   //demo menu 
		cout << "**** Demo Menu *****\n[1] Three consecutive '6'\n[2] Chess touches home and reverses, reaches home and wins\n[3] Chess does not self - overlap, and sends back opponent chess" << endl;
		cout << "[4] Return to Game Menu\n*********************\nOption(1 - 4) :";

		num = errorcheck();

		system("cls");
		switch (num)
		{
		case 1:
		{
			democase1();
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');

			system("cls");
			continue;
		}
		case 2:
		{
			democase2();
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');

			system("cls");
			continue;
		}
		case 3:
		{
			democase3();
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');

			system("cls");
			continue;
		}
		case 4:
		{
			return;
		}
		default:
		{
			invalid();
		}
		}
	} while (num != 4);
}

void instructions()// Rules
{
	cout << "**** Rules *****\n\n*********************\n\n";
	cout << "1.To have a chess leaving \"Base\" and entering the game board, a player must\nroll\'6\'.If the player has no chess on the game board and fails to roll \'6\', the\nturn passes to the next player.\n\n";
	cout << "2.If a player has one or more chess to move, he chooses a movable chess from the given\nlist and moves the chess along the path by the number of positions\naccording to the rolling result.\n\n";
	cout << "3.If a player rolls a \'6\', he gets a bonus turn.If the bonus turn rolls a \'6\'again,\nhe gets one more bonus turn. However,the third time he rolls a \'6\', no more bonus turn and\n";
	cout << "he need to passes to the next player after moving that turn\n\n";
	cout << "4.A player cannot move a chess into a location that is occupied by other chesses of\nthat player.\n\n";
	cout << "5.If a chess ends on a position occupied by an opponent's chess, the opponent chess\n";
	cout << "is sent back to the opponent's \"Base\".Any chess that has reached \"Home\" should\n";
	cout << "be \"safe\" from being sent back.\n\n";
	cout << "6.A chess can reaches \"Home\" only if it exactly steps on \'X\'.If the rolling value\n";
	cout << "exceeds the number of steps required, the chess will move backward for the\n";
	cout << "remaining steps.\n\n";
}

void credits()
{
	cout << "List of Developer:" << endl;
	cout << left << setw(17) << "Chui Kwan Kit" << right << setw(12) << "17020410A" << setw(7) << "103A" << endl;
	cout << left << setw(17) << "Kwok Ka Chun" << right << setw(12) << "17016468A" << setw(7) << "103C" << endl;
	cout << left << setw(17) << "Kwok Tsz Kit" << right << setw(12) << "17139051A" << setw(7) << "103D" << endl;
	cout << left << setw(17) << "Lam Ka Kin" << right << setw(12) << "17109243A" << setw(7) << "103C" << endl;
	cout << left << setw(17) << "Liu Ka Chun" << right << setw(12) << "17135304A" << setw(7) << "103D" << endl;
	cout << endl;
}

void welcome() //welcome message
{

	int const time = 1e7;
	for (int i = 0; i <= 30; i++) {
		for (int j = 0; j <= time; j++) {}
		system("cls");
		cout << setw(50 - i) << "*   * **** *     **   **  *   * ****\n" << setw(50 - i) << "* * * *    *    *  * *  * ** ** *   \n" << setw(50 - i) << "* * * **** *    *    *  * * * * ****\n" << setw(50 - i) << "* * * *    *    *  * *  * *   * *   \n" << setw(50 - i) << " * *  **** ****  **   **  *   * ****\n";
	}
	for (int i = 0; i <= 30; i++) {
		for (int j = 0; j <= time; j++) {}
		system("cls");
		cout << "*   * **** *     **   **  *   * ****  " << setw(30 - i) << "   *****  ** \n" << "* * * *    *    *  * *  * ** ** *     " << setw(30 - i) << "     *   *  *\n" << "* * * **** *    *    *  * * * * ****  " << setw(30 - i) << "     *   *  *\n" << "* * * *    *    *  * *  * *   * *     " << setw(30 - i) << "     *   *  *\n" << " * *  **** ****  **   **  *   * ****  " << setw(30 - i) << "     *    ** \n";
	}
	for (int i = 0; i <= 30; i++) {
		system("cls");
		cout << "*   * **** *     **   **  *   * ****     *****  ** \n" << "* * * *    *    *  * *  * ** ** *          *   *  *\n" << "* * * **** *    *    *  * * * * ****       *   *  *\n" << "* * * *    *    *  * *  * *   * *          *   *  *\n" << " * *  **** ****  **   **  *   * ****       *    ** \n\n" << setw(30 - i) << "*    *   * ***   ** \n" << setw(30 - i) << "*    *   * *  * *  *\n" << setw(30 - i) << "*    *   * *  * *  *\n" << setw(30 - i) << "*    *   * *  * *  *\n" << setw(30 - i) << "****  ***  ***   ** \n";
		for (int j = 0; j <= time; j++) {}
	}
	for (int i = 0; i <= 30; i++) {
		system("cls");
		cout << "*   * **** *     **   **  *   * ****     *****  ** \n" << "* * * *    *    *  * *  * ** ** *          *   *  *\n" << "* * * **** *    *    *  * * * * ****       *   *  *\n" << "* * * *    *    *  * *  * *   * *          *   *  *\n" << " * *  **** ****  **   **  *   * ****       *    ** \n\n" << "*    *   * ***   **   " << setw(30 - i) << "    ***  **  *   * ****\n" << "*    *   * *  * *  *  " << setw(30 - i) << "   *    *  * ** ** *   \n" << "*    *   * *  * *  *  " << setw(30 - i) << "   * ** **** * * * ****\n" << "*    *   * *  * *  *  " << setw(30 - i) << "   *  * *  * *   * *   \n" << "****  ***  ***   **   " << setw(30 - i) << "    **  *  * *   * ****\n";
		for (int j = 0; j <= time; j++) {}
	}
	system("cls");
	cout << "*   * **** *     **   **  *   * ****     *****  ** \n" << "* * * *    *    *  * *  * ** ** *          *   *  *\n" << "* * * **** *    *    *  * * * * ****       *   *  *\n" << "* * * *    *    *  * *  * *   * *          *   *  *\n" << " * *  **** ****  **   **  *   * ****       *    ** \n\n" << "*    *   * ***   **       ***  **  *   * ****\n*    *   * *  * *  *     *    *  * ** ** *   \n*    *   * *  * *  *     * ** **** * * * ****\n" << "*    *   * *  * *  *     *  * *  * *   * *   \n" << "****  ***  ***   **       **  *  * *   * ****\n";

}

int main()
{
	int num;
	welcome();// Welcoming message

	cout << endl;
	system("pause");
	system("cls");

	do
	{


		cout << "*** Game Menu ***\n[1] Start Game\n[2] Settings\n[3] Game Demo\n[4] Instructions\n[5] Credits\n[6] Exit\n*****************\nOption(1 - 6):";


		num = errorcheck();

		system("cls");

		switch (num)
		{
		case 1:
		{
			start_game();
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			continue;
		}
		case 2:
		{
			settings();
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			continue;
		}

		case 3:
		{
			demo();
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			continue;
		}
		case 4:
		{
			instructions();
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			continue;
		}
		case 5:
		{
			credits();
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			continue;
		}
		case 6:
		{
			char x; //input validation check
			do
			{
				cout << "Are you sure to leave the game? (Y/N):";
				x = validcheck();
				if (x == 'y' || x == 'Y')
				{
					bye();
					return 0;
				}
				else if (x == 'N' || x == 'n')
				{
					continue;
				}
				else
				{
					system("cls");
					invalid();
					x = 'p'; //keep looping
				}
			} while (x == 'p');

			num = 1; //return menu 
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			system("cls");
			continue;
		}
		default:
		{
			invalid();
		}
		}
	} while (num != 6);
	return 0;
}
